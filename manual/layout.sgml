<chapt> Coda Source Layout <p>

This chapter is a guide to using and modifying Coda source code at CMU-SCS.
It is mainly intended to help new members of the project come up to speed.
But it may also help sites outside CMU that receive a Coda distribution to devise
procedures appropriate to their environments.


<sect>The Big Picture<p>

All files relating to Coda, with the sole exception of RCS files (see Section <ref id="RCS)" name="XXX">,
are stored in <tt>/coda/project/coda.</tt>  Lets call this <tt>&dollar;CODA.</tt>
The directories under <tt>&dollar;CODA</tt>  correspond to different <em>releases</em> of Coda, such as
<tt>alpha,</tt> <tt>beta,</tt> and so on.  A release is a complete set of <em>mutually consistent</em>
sources, libraries and binaries.   "Mutually consistent" means, for example, that the
Venus and server from a release will work with each other.  It also means that you can
freely use the libraries and include files to compile new binaries in that
release.   @ux&lsqb;There are no guarantees of any kind across releases.&rsqb;

Before a new instance of a release is made, careful thought must be given as to how current
users of that release will be affected.   Will all such users have to be upgraded in one
fell swoop?  Or can they switch over at their own leisure?   As the deployed Coda system grows,
upgrading everyone in one fell swoop gets harder.  After all, some of the users may be in hiding
with their disconnected laptops!

By convention, the <tt>omega</tt> release corresponds to the version of Coda in production 
use.  Most users Venii, as well as the servers on production machines, 
are from this release.  Hence the value of <tt>/usr/coda/SYMLINK</tt> on those users workstations
is <tt>&dollar;CODA/omega</tt>.

<sect1>How versions evolve<p>

The <tt>alpha</tt> release of software corresponds to a lightly tested version of the system.
Individual developers have done a significant amount of testing of <tt>alpha</tt> software, but
it hasnt yet been stressed heavily, nor has it been tested in real use.  Hence <tt>alpha</tt>
server code should not be run on servers that hold real user data.  They should only be
run on the <tt>alpha</tt> servers (also known as "test" servers).  Similarly for other <tt>alpha</tt>
software.  When you are doing code development, you
usually pick up include files and libraries from the <tt>alpha</tt> release.  Thus, the 
private versions of software you build is, at best, of <tt>alpha</tt> quality.

The <tt>beta</tt> release corresponds to a version of the system that is expected to be released
soon for production use.
A small number of users, typically members of the Coda project, depend upon
this release.  Actual use by such users is part of the testing of the <tt>beta</tt> 
release.  Eventually, when we have enough confidence in the stability and correctness of
the <tt>beta</tt> release, we promote it <tt>omega.</tt> 

<tt>beta</tt> is really a symlink to a volume mount point <tt>beta-&lt;unique&gt;</tt>, 
where <tt>&lt;unique&gt;</tt> is an identifier made up by the <tt>makebeta</tt> script described below.
Upgrading the <tt>beta</tt> release consists of creating a new volume, mounting it
at <tt>beta-&lt;unique&gt;</tt>, populating it using the steps described in Section <ref id="alphatobeta" name="XXX">,
and finally changing the <tt>beta</tt> symlink to point to <tt>beta-&lt;unique&gt;</tt>.
The old  <tt>beta</tt> volume is preserved for a while, until is clear
that the new release hasnt triggered any serious problems.  It can then be purged
to reclaim space, or recycled for a future beta release.

<tt>omega</tt> is also a symlink to a volume mount point <tt>beta-&lt;unique&gt;</tt>.
After a <tt>beta</tt> release has been running robustly for a while, it is upgraded
to <tt>omega</tt> by merely changing the value of the <tt>omega</tt> symlink.  No recompilation
is involved.

When a <tt>beta-&lt;unique&gt;</tt> release is created, the <tt>makebeta</tt> script creates an RCS branch
named <tt>beta-&lt;unique&gt;</tt> for every file in the release.
Normally no development or changes are done along this branch.
However, it provides a way to introduce an emergency fix 
in a <tt>beta</tt> or <tt>omega</tt> release if the need ever arises.

<sect1>How code is developed<p>
<label id="CodeDevelopment">

Lets illustrate this with a specific example. Suppose I want to upgrade the module
<tt>rpc2</tt> and build a new Venus to use the upgrade.   I  begin by creating two 
private directories, say <tt>/coda/usr/satya/src/rpc2</tt> and <tt>/coda/usr/satya/src/venus</tt>,
and populating them with source files from the <tt>alpha</tt> release of these two modules.
Section <ref id="RCS" name="XXX"> tells you how this step actually gets done.  Now I proceed to modify files in
<tt>rpc2</tt> and to compile and test the module using standalone test programs.   
Then I modify files in <tt>venus</tt> to use the upgrade and then build a Venus.
When building Venus, I must make sure that the version of <tt>rpc2</tt> used is the one I just built.
Section <ref id="Changes" name="XXX"> tells you how to do this.  Now I have a Venus that I can test.
As bugs are found in the new Venus, I iterate the above procedure.
When I am confident that my changes to <tt>rpc2</tt> and <tt>venus</tt> are right, I update the <tt>alpha</tt>
release of these two modules.

The process of updating the <tt>alpha</tt> release is known as <em>installation.</em>  
Installation is the point at which work done by a Coda project member
becomes visible to others in the project.  Prior to this point, all work is done in
that users own private directory.
Installation always occurs at the granularity of entire <em>modules.</em>  In other words, one never
installs an individual library, include file, etc.   Rather the entire source code for a module and
all relevant files compiled from it are installed together.  Modified files are automatically
checked into RCS as part of the installation procedure.
At some future time, these changes along with many others that were installed
will make it into a <tt>beta</tt> release.  Section <ref id="PromotingReleases" name="XXX"> shows you how
this is done.  After some use as <tt>beta</tt>, it will be promoted to <tt>omega</tt>.


<sect>Layout of Source Code<p>
<sect1>Layout of a Release<p>
Each release has the structure shown in Figure <ref id="ReleaseLayout" name="XXX">.  Note that this layout
is identical for all releases.

<figure>
  <eps file="coda-releases-fig">
<caption><label id="ReleaseLayout">Structure of a Coda Release </caption>
</figure>
<tscreen>
The underlined names are symlinks to machine-specific directories.
On a 386 machine for example, @ux&lt;<tt>bin</tt>&gt; is a symlink to <tt>i386&lowbar;mach/bin.</tt>
Although only two machine-specific directories (<tt>pmax&lowbar;mach</tt> and <tt>i386&lowbar;mach</tt>) are shown, there
can be many more.
</tscreen>


The source tree for the release is in <tt>src</tt>.  A copy of the header files from <tt>src</tt>
is in <tt>include</tt>.  Both <tt>src</tt> and <tt>include</tt> are machine-independent.  For each
supported machine type, there is a directory containing binaries (<tt>bin</tt>) and libraries (<tt>lib</tt>).
The source tree in a release is fully self-contained.  In other words, if you started out with empty
<tt>include,</tt> <tt>lib,</tt> and <tt>bin</tt> directories, you could completely populate them by compiling
the source code in <tt>src</tt>.  The only exception to this are the files in <tt>include-special,</tt>
<tt>lib-special,</tt> <tt>src-special,</tt> and <tt>bin-special</tt>.  These directories contain a very small number of files
that have to be copied in by hand.   The sources for these files are not in <tt>src</tt>.


<sect1>Layout of the source directory<p>
The <tt>src</tt> directory in each release is organized as in Figure <ref id="SrcLayout" name="XXX">.  The <tt>MAKECODA</tt>
script simplifies the compilation of the entire release.  The <tt>Makeconf</tt> file defines in
a single spot many key variables and paths used by the makefiles in individual modules.  Those
makefiles inherit these definitions automatically, when the CMU-SCS <tt>make</tt> is used.
The <tt>SOURCEME</tt> file contains a minimal set of environment definitions.  By sourcing this
file before you compile anything, you can be sure that you arent obtaining binaries, libraries
etc. from non-standard places.   This is especially important if your <tt>.login</tt> or <tt>.cshrc</tt>
files define elaborate <tt>PATH, CPATH, LPATH</tt> variables.

<figure>
  <eps file="coda-src-fig">
  <caption><label id="SrcLayout">Structure of the source directory in a release
</caption>
</figure>
<tscreen>
The underlined names are symlinks to RCS directories.  For example, <tt>RCSLINK</tt> is a
symlink to <tt>/afs/cs/project/coda/rcs</tt>; <tt>auth2/RCS</tt> is a symlink to <tt>../RCSLINK/auth2</tt>;
and so on.  Indirecting via <tt>RCSLINK</tt> makes it simple to relocate the RCS directories
without changing lots of individual symlinks.  Such relocation might happen, for example,
when Coda sources are used outside CMU.
</tscreen>

<sect1>Layout of a typical module<p>
The structure of a typical module is shown in Figure <ref id="ModuleLayout" name="XXX">.
<figure>
<eps file="coda-module-fig">
<caption> <label id="ModuleLayout">Structure of a typical module</caption>
</figure>

<tscreen>
This figure depicts the structure of one module, <tt>rpc2</tt>.
The underlined name RCS is a symlink to <tt>../RCSLINK/rpc2</tt>.
Indirecting via <tt>RCSLINK</tt> makes it simple to relocate the RCS directories.
</tscreen>

Notice that only the source files are located in this directory; there are no object
files.  The CMU-SCS <tt>make</tt> facility puts all compilation targets elsewhere, thus
allowing the source directory to be readonly.  This has two advantages.  First, the
source directories are uncluttered.  Second, it simplifies building Coda for multiple
machine types, since the target directories can be different for each machine type.

Also notice the presence of multiple makefiles in this module.  Although this is not
characteristic of all Coda modules, it is typical of some.  The true dependencies are
capture in <tt>Makefile.real</tt>, and the others, like <tt>Makefile.coda</tt> and <tt>Makefile.misc</tt>
invoke <tt>Makefile.real</tt> after defining environment variables appropriately.  This simplifies
the use of these modules outside Coda.   If you are compiling by hand, you have to say
"<tt>make -f Makefile.coda &lt;target&gt;</tt>", rather than just "<tt>make &lt;target&gt;</tt>".


<sect>Module Dependencies<p>
<label id="Dependencies">

Most Coda modules rely on files installed by other Coda modules.  It is
therefore important to install modules in the correct order.
Otherwise you could get yourself into real trouble.  If you are
compiling from scratch, the out-of-order installations will simply fail.
But if you are modifying an existing release, you could end up
with mysterious bugs because obsolete versions of header files and libraries
may be used.

You are @ux&lsqb;strongly&rsqb; urged to use the script <tt>MAKECODA,</tt> described in Section <ref id="MAKECODA" name="XXX">.
The correct precedences of modules are wired into the script, so you dont have to
deal with them.

For the curious, the correct order of compilation of modules is given below.
In principle, modules of the same precedence (i.e. in the same set) can be compiled in
parallel.  But I havent actually tried that yet.

<enum>
<item>
<tt>scripts</tt> Miscellaneous scripts, including <tt>alphaci</tt> on which intalls of all other modules rely 
<item>
<itemize>
<item>
<tt>mlwp</tt> Lightweight process package 
<item>
<tt>dir</tt> Directory package used by Venus and server 
<item>
<tt>sys</tt> Miscellaneous routines 
<item>
<tt>sunrpc</tt> Sun Microsystems public domain XDR code and interface for device driver/venus interaction 
<item>
<tt>igmp</tt> Internet multicast support for old RFC
 (dummied out currently; someone should fix these to use the new RFC) 
<item>
</itemize>
<item>
<itemize>
<item>
<tt>util</tt> Utility routines 
<item>
<tt>rpc2</tt> RPC package 
<item>
</itemize>
<item>
<itemize>
<item>
<tt>camstuff</tt> Header files that allow runtime choice of RVM or VM for persistence on servers 
<item>
<tt>blurb</tt> Program to adjust copyrights 
<item>
<tt>pdbstuff</tt> Protection database management 
<item>
<tt>rp2gen</tt> Stub generator for RPC2 
<item>
<tt>comm</tt> Communication layer above RPC2 for connection management (not yet in use) 
<item>
<tt>libal</tt> Access list package. 
</itemize>
<item>
<itemize>
<item>
<tt>vicedep</tt> Header files and RPC2 interface definition files put here to break circular dependencies 
<item>
<tt>fail</tt> Network failure and variable speed emulator 
<item>
<tt>auth2</tt> Authentication server 
</itemize>
<item>
<itemize>
<item>
<tt>login</tt> Implements clog, cunlog, ctokens, etc. 
<item>
<tt>cfs</tt> The VFS driver; most of this code is linked into the Mach kernel 
<item>
<tt>vv</tt> Version vector routines 
<item>
<tt>mond</tt> Coda usage data collector 
</itemize>
<item>
<itemize>
<item>
<tt>resolve</tt> Library used by repair (should get integrated into <tt>repair</tt>) 
<item>
<tt>vol</tt> Volume package used by server 
</itemize>
<item>
<itemize>
<item>
<tt>res</tt> VM-based directory resolution algorithms 
<item>
<tt>repair</tt> Repair tool 
<item>
<tt>venus</tt> Cache manager 
</itemize>
<item>
<itemize>
<item>
<tt>volutil</tt> Volume utilities 
<item>
<tt>vtools</tt> Miscellaneous Venus tools 
<item>
<tt>rvmres</tt> RVM-based directory resolution algorithms  
</itemize>

<item>
<itemize>
<item>
<tt>vice</tt> Server code 
</itemize>

<item>
<itemize>
<item>
<tt>update</tt> The daemon which updates server databases 
<item>
<tt>norton</tt> A Coda server, RVM debugger 
<item>
<tt>asr</tt> Application Specific Resolver package 
<item>
<tt>egasr</tt> ASR examples@end)annote
</itemize>
</enum>



<sect>Building a Release<p>

<sect1>Prerequisites<p>
<label id="Prerequisites">
To compile Coda "out of the box" you need the following compilation tools:
<itemize>
<item>Gnu g++ compiler version 2.5.8 or higher.
<item>
CMU-SCS <tt>make</tt> The makefiles in the Coda sources exploit many of the enhancements
made by CMU to Unix make.  Conditional macro expansion, the ability to place targets
in a different place from the sources, and the inheritance of variable definitions from
Makeconf are the three major features we rely on.
<item>
C compiler on IBM-RTs It is important that the compiler be set to use <tt>long</tt> to represent <tt>enum</tt>.
The RT C compilers default behavior of using <tt>char</tt> to represent small-valued enums will
cause insidious problems in RPC2 communication.  On CMU-SCS machines this is done by defining the
environment variable <tt>PLAINC</tt> to be <tt>/usr/misc/.hc/bin/hc2</tt>.  The <tt>MAKECODA</tt> script does this
automatically for you, but you must remember to do this manually if you arent using it. (Some <tt>.login</tt>s have the variable <tt>ccC</tt> defined to <tt>hc</tt>; you must delete this definition
also).
</itemize>

It should be possible to modify the code to use other versions of C++
(such as <tt>g++</tt>), or to use standard Unix make.  But we havent
tried this, and dont plan to.

<sect1>Special directories<p>
<label id="SpecialDirectories">

Before you can compile Coda, you need to populate the <tt>&lcub;include,lib,bin,src&rcub;-special</tt> directories.
These contain files that are (a) needed but arent in the Coda sources or (b) standard Mach header files, with slight modifications.   The <tt>MAKECODA</tt>
script contains an up-to-date list of what these files should be.  Here is
a list that was current at the time of writing this document:
<descrip>
<tag/RVM files/RVM is a lightweight transactional package that is used on servers and clients.
It is a package that is independent of Coda.  The current set of files from this package are:
<tscreen><verb>
include-special/&lcub;rvm.h,rvm&lowbar;lwp.h,rvm&lowbar;statistics.h,
			rvm&lowbar;segment.h,rds.h&rcub;

lib-special/&lcub;librvm.a,librvmlwp.a,libseg.a,librds.a&rcub;

bin-special/&lcub;rdsinit,rvmutl&rcub;

src-special/&lcub;Makeconf,Makefile,READ&lowbar;ME,plumber,rds,rvm,seg&rcub;
</verb></tscreen>
<tag/Tracing facility files/These files pertain to a file tracing facility, <tt>dfstrace</tt>, that is 
used at CMU.  Venus is capable of functioning as a simulator driven by traces.   This requires
the following files:
<tscreen><verb>
include-special/tracelib.h

lib-special/libtrace.a
</verb></tscreen>
If you dont intend to use Venus as a simulator, you could construct a dummy <tt>libtrace.a</tt> with
empty routines to avoid unresolved references.   You do need <tt>tracelib.h</tt> though.
<tag/Plumber/ <tt>malloc</tt> The Coda makefiles allow you to build versions of <tt>venus</tt> and <tt>srv</tt> 
that use a special <tt>malloc</tt> to help detect memory leaks.  The following files are needed
for this:
<tscreen><verb>
include-special/newplumb.h

lib-special/&lcub;libplumber.a,libnewplumb.a&rcub;
</verb></tscreen>
If you dont plan to build the plumbing facilities, you can just create zero-length files with
these names to keep the <tt>MAKECODA</tt> script happy.
<tag/Modified Mach headers/The changes in these files had to be made because of compilation errors
from C++, or (as in the case of <tt>assert.h</tt>) to define different behavior for standard macros:
<tscreen><verb>
include-special/&lcub;assert.h,cthreads.h,setjmp.h,sys/inode.h,
			i386/fpreg.h,i386&lowbar;mach/endian.h&rcub;
</verb></tscreen>
</descrip>

<sect1>Using the MAKECODA script<p>
<label id="MAKECODA">

Once you have taken care of the prerequisites and special files, you can compile a release.
The simplest way to do this is to run the <tt>MAKECODA</tt> script in <tt>src</tt>.  
This script takes one required and two optional arguments. 
The required argument is <tt>OBJECTDIR</tt>, which is the pathname of
the directory where the object files should be placed.  It is sensible to specify a different
directory for each machine type, and the <tt>@@sys</tt> facility of AFS and Coda lets you do this.

So, for example, to compile the <tt>beta</tt> release, I would do the following:

<tscreen>
<verb>
cd /coda/project/coda/beta/src
./MAKECODA OBJECTDIR=/coda/usr/satya/OBJS/@@sys
</verb>
</tscreen>

The <tt>MAKECODA</tt> script will first check to make sure that all necessary special
files are present.  If any are missing it will prompt you.  It then goes through
the Coda modules in the correct order, and does a <tt>make install</tt> on each of
them.  The usual checkin to RCS that is done by <tt>alphaci</tt> 
as part of <tt>make install</tt> (see Section <ref id="alphaci)" name="XXX"> is supressed.
If all goes well, everything in Coda will be compiled, and the <tt>bin</tt>, <tt>lib</tt>,
and <tt>include</tt> directores will be populated.  You will have to repeat this once
for each machine type.

Sometimes, you will run into a problem part-way through <tt>MAKECODA</tt>.   After you
have fixed the problem, youd probably like to continue where you left off rather
than redoing everything from the beginning.  Hence <tt>MAKECODA</tt> lets you specify
the name of the module to start from.  Here is an example:
<tscreen>
<verb>
./MAKECODA OBJECTDIR=/tmp/@@sys FIRSTMODULE=vol
</verb>
</tscreen>

Finally, the pathname of the root of the release you are compiling is specified by
the variable <tt>ROOT</tt> in <tt>MAKECODA</tt>.  You can change this by editing <tt>MAKECODA</tt>,
and this is in fact what the <tt>makebeta</tt> script does for you when you create a new release.
But you can also override it on the command line thus:
<tscreen>
<verb>
cd /tmp
MAKECODA OBJECTDIR=/tmp/@@sys  ROOT=/coda/project/coda/alpha
</verb>
</tscreen>

<sect>Making Incremental Changes<p>
<label id="Changes">

Once the <tt>alpha</tt> release has been built, you can start code development.
We have already seen the general procedure in Section <ref id="CodeDevelopment" name="XXX">.
Lets look at an example in more detail.

Suppose I am working on the module <tt>vtools</tt> and need to change
the files <tt>cmon.c</tt> and <tt>codacon.c</tt>.  Heres what I would do:
<tscreen>
<verb>
# Create a scratch directory for my work
mkdir /coda/usr/satya/src
cd /coda/usr/satya/src

# Set up links to RCS directory, and root of release
ln -s /afs/cs/project/coda/rcs/coda-1.0 RCSLINK
ln -s /coda/project/coda/alpha/src SRCROOT
ln -s SRCROOT/Makeconf

# Create directory for this module
mkdir vtools
cd vtools
ln -s ../RCSLINK/vtools RCS

# Lock and checkout the file (s) to be modified
rcsco -l cmon.c codacon.c

# Now edit cmon.c and codacon.c

# Then compile this module
# Source the standard environment file to make sure your 
# compilation environment (PATH, LPATH, CPATH, etc.) is set up right 
source ../SRCROOT/SOURCEME
make OBJECTDIR=/coda/usr/satya/OBJS/@@sys cmon codacon

# Test cmon & codacon, then iterate on edit/debug cycle above

# Now you are ready to install your changes.
# You must first create a file called RCSMSG, and enter text
# in it that will become the RCS log message for the checkin.
# It will also be posted to the changelog bboard, so that 
# others in the group will know of your installation

echo "Fixes to annoying bugs ... blah blah blah ..." &gt; RCSMSG
make OBJECTDIR=/coda/usr/satya/OBJS/@@sys install

# You are now done!
# The install step automatically released the write locks on cmon.c
# and codacon.c

# Repeat the install step for each of the other supported platforms.
</verb>
</tscreen>

Notice that many other files may be need for compilation,
but you dont have to check them out.  This is because the CMU-SCS 
make knows to check out any needed files automatically into the compilation
target area.

<sect1>The alphaci script<p>
<label id="alphaci">

The automatic checkin is done by a script called <tt>alphaci</tt> that is invoked
as the last step of <tt>make install</tt>.  <tt>alphaci</tt> will give you an error if
the <tt>RCSMSG</tt> file is missing; it moves it to <tt>RCSMSG.old</tt> once it has
checked in files.  <tt>alphaci</tt> is smart enough to discover new files that
arent mentioned in RCS, and prompts you to ask if you want them checked in
too.  Often you may not want this, because the files in question were just
test files created for debugging.  <tt>alphaci</tt> assumes that only writable
files should be checked in; it prompts you about what to do with files that
are not writable.

The RCSMSG file is also used by <tt>alphaci</tt> for posting on the changelog bboard (<tt>cmu.cs.proj.coda.changelog</tt> at CMU).  You should follow the posts on this
bboard closely, so that you are aware of changes to Coda modules by other
project members.  Here are some typical posts from the bboard:
<tscreen>
<verb>
03-Feb-93 18:56   M Satya   Installed scripts for IBMRT
Posted by alphaci from STRAUSS.CODA.CS.CMU.EDU
No files checked into RCS

03-Feb-93 18:50   M Satya   Installed scripts for I386
Posted by alphaci from WEBER.CODA.CS.CMU.EDU
No files checked into RCS

03-Feb-93 18:22   M Satya   Installed scripts for PMAX
Posted by alphaci from MOZART.CODA.CS.CMU.EDU
Files checked into RCS:      Makefile makebeta restartserver restore.sh
RCS message follows:
Created new script, makebeta, to make a clone of the entire alpha
source tree, and to create branches in RCS for all files.
</verb>
</tscreen>
Notice how the installations for machine types I386 and IBMRT caused no RCS
files to be checked in.  This is because the installation for the first machine
type, PMAX, did the checkin.


<sect>Promoting Releases<p>
<label id="PromotingReleases">

As we have seen earlier, there are 3 important releases of software:
<tt>alpha,</tt> <tt>beta,</tt> and <tt>omega</tt>.   Servers are also classified 
by this scheme.  At the time of writing this document, there were 
3 <tt>omega</tt> servers (<tt>rossini</tt>, <tt>puccini</tt>, and <tt>scarlatti</tt>),
3 <tt>beta</tt> servers (<tt>grieg</tt>, <tt>haydn</tt>, and <tt>wagner</tt>), and
4 <tt>alpha</tt> servers (<tt>schumann</tt>, <tt>gershwin</tt>, <tt>mahler</tt>, and <tt>vivaldi</tt>).

The <tt>omega</tt> servers hold real data, so software let loose on them should
have been tested very well.  Having to reinitialize and to restore many gigabytes on 
the <tt>omega</tt> servers because of storage corruption is not an experience
you are likely to forget!  The <tt>beta</tt> servers hold some real data, but
the number of users depending on that data is restricted to a few Coda project
members.  Further, that data is of a kind that can be easily reconstructed.  
The <tt>alpha</tt> servers are used by project members for testing.
Obviously, only one person can test their software on a server at a time, so you
should coordinate use of the servers with the other members.

<sect1>Promoting alpha to beta<p>
<label id="alphatobeta">

When the <tt>alpha</tt> release has diverged substantially from <tt>beta</tt>,
and is relatively stable, we will decide to make a new <tt>beta</tt> release.
One member of the Coda project will serve as <em>release coordinator</em> for the promotion.


The first step in this process is for the release coordinator to post on
<tt>cmu.cs.proj.coda.general</tt>, asking project members to checkin changes and to drop
all RCS locks on the main line of development by a certain deadline.  
As soon as possible you should release all mainline locks.  It is ok to 
hold on to locks on private branches.  Once the deadline expires, the release
coordinator will feel free to break mainline locks.

In the second step, the release coordinator runs the <tt>makebeta</tt> script to
create a clone of the current state of <tt>alpha</tt>.  <tt>makebeta</tt> first
synthesizes a unique identifier of the form <em>date&lowbar;xxxxx</em> where <em>xxxxx</em> is
the number of seconds since midnight.   The name of the new release is then
<tt>beta-&lt;unique identifier&gt;</tt>; for example, <tt>beta-3Feb1993&lowbar;43696</tt>.
This name is used to tag a new RCS branch for every file in the release,
so that emergency fixes are possible long after the <tt>alpha</tt> release has
diverged from this <tt>beta</tt> release.

The <tt>makebeta</tt> script works as follows:
<itemize>
<item>First, it constructs a unique
name for the release, as described above.  It then pauses, waiting for the
user to construct a directory with this name.  Usually, the release coordinator
makes this name the mount point of a new volume.  <tt>makebeta</tt> checks to make
sure the directory is empty before proceeding, to avoid accidental clobbers.
For brevity, we refer to this directory as <tt>&dollar;BETA</tt>.
<item>
Second, <tt>makebeta</tt> looks at <tt>/coda/project/coda/alpha/src</tt> (<tt>&dollar;ALPHA/src</tt>, for short)
and determines the names of the modules in it.
<item>
Third, it makes a copy of the <tt>&dollar;ALPHA</tt> modules in <tt>&dollar;BETA</tt>.  In making this copy,
it actually checks out the files (unlocked) from RCS, and compares them with <tt>&dollar;ALPHA</tt>.
This is a sanity check, to ensure that RCS and <tt>&dollar;ALPHA</tt> are in sync.  One side effect
of this comparison is to detect RCS locks.
<item>
If any locks were detected, or if any files in RCS differed from their copies in 
<tt>&dollar;ALPHA</tt>, <tt>makebeta</tt> pauses and asks the user to go take a look at whats wrong.
It then asks the user whether to proceed.
<item>
Next, <tt>makebeta</tt> creates a new RCS branch, named after this release, and re-checks
out files from the branch so that <tt>&dollar;Header&dollar;</tt> in those files is correctly set.
<item>
At this point, the files <tt>MAKECODA</tt> and <tt>Makeconf</tt> at the top level of <tt>&dollar;BETA</tt>
are edited by <tt>makebeta</tt> so that all references to <tt>&dollar;ALPHA</tt> are changed to <tt>&dollar;BETA</tt>.
<item>
Finally, <tt>makebeta</tt> copies over all the special directories (<tt>&lcub;lib,bin,src,include&rcub;-special</tt>).
</itemize>

The above procedure is quite slow, since many RCS interactions are involved.  It usually takes
a few hours.   If all goes well, <tt>makebeta</tt> requires little babysitting.
Note that the script does no locking.  In other words, the <tt>&dollar;ALPHA</tt> tree better remain
frozen for the entire duration of the promotion.  

In the third step, the release coordinator <tt>cd</tt>s into <tt>&dollar;BETA/src</tt>, and runs <tt>MAKECODA</tt>
once for each machine type.   Note that he doesnt have to specify anything other than <tt>OBJECTDIR</tt>,
since <tt>makebeta</tt> has already set <tt>ROOT</tt> correctly in the <tt>MAKECODA</tt> script.  This step
guarantees that the binaries in <tt>&dollar;BETA</tt> were indeed compiled from the sources in <tt>&dollar;BETA</tt>.

In the final step, the release coordinator makes the symlink <tt>beta</tt> point to <tt>&dollar;BETA</tt>.
This is the "commit" step that blesses the newly-cloned release as the <tt>beta</tt> release.

<sect1>Promoting beta to omega<p>

After the <tt>beta</tt> release has been stressed for some time, 
it will be promoted to <tt>omega</tt>.  This is a much simpler procedure than the 
<tt>alpha</tt> to <tt>beta</tt> promotion.  The release coordinator merely has to make the 
symlink <tt>omega</tt> point to the <tt>beta-xxxx</tt> where <tt>xxxx</tt> is the unique
identity of the release being promoted.  This "commit" step blesses what was
hitherto <tt>beta</tt> as <tt>omega</tt>

<sect>Copyright Notices<p>

Since Coda is distributed outside CMU, it is important that
every source file  contain a copyright notice.  The <tt>blurb</tt> program
simplifies adding and changing copyright notices.  <tt>blurb</tt> expects
to find the copyright notice is at the very beginning of a file, so make
sure you dont move it when modifying a file.

The only modules without Coda copyright notices are <tt>sunrpc,</tt>
which is public-domain code from Sun, and <tt>cfs,</tt> which is mostly
Mach kernel code.

Some files in Coda are derived from the 1986 version of AFS-2.0.
Since AFS-2.0 is owned by IBM, these files have an IBM copyright notice in
addition to the Coda copyright notice.

When you modify a file or add a new file, you should pay attention
to the copyright notices.   Here are some simple rules to follow:
<enum>
<item>
If you add new files, just include the Coda copyright notice.
   By definition, new code is not derived from AFS-2.0 and should
   not receive an IBM copyright notice.
<item>
If you modify an existing file, dont do anything with the copyright
   notice.   All else being equal, add new code to new files, or to existing
   files without the IBM copyright notice.  But use good judgement here
   -- if it is clear that the correct home for a piece of code is a file with
   an IBM copyright notice, go ahead and put it there.
<item>
If you make a substantial copy of a file with an IBM copyright notice
   then the copy also acquires the IBM copyright notice.  The 
   interpretation of "substantial copy" is, of course, subjective.
   If you copy a variable declaration, it is not a "substantial copy".
   If you copy a whole bunch of procedures or macros, it is definitely
   a "substantial copy". 
</enum>

A simple way to think of this is that some files in Coda are "tainted"
   (i.e., they are derived from AFS-2.0).  Tainted files can infect other
   files if enough of their innards are copied.  Existing untainted files,
   and new files, stay untainted forever.
In general, do your best to keep the number of tainted files to a minimum.
Note that this discipline regarding copyrights is not intended to be
onerous or constraining --- just common sense and a little self-discipline.

<sect>Using RCS for Revision Control<p>
<label id="RCS">


<tscreen><verb>
1. Branch overview

One common problem in managing large software projects comes
to play when there are several people working on the same sets
of files. RCS helps by providing per-file locking to guarantee
that no two users modify the same file at the same time. If
several users are modifying the same line of development,
however, this locking does nothing to guarantee that one users
changes in one file wont interfere with another users changes
in another file.

To combat this problem, RCS provides the notion of a "branch".
A branch is a separate line of development carried out in parallel
to the main line of development. Version found on branches have
more than two digits in their version numbers. All digits make up
the version number of an element on a branch. For example, version
1.2.1.1 is an element in the first branch off of version 1.2. 

As branch numbers are hard to deal with,  you  are recommended to
assign symbolic names to branches.


2. How to use branch

For example, a typical command to create and name a branch would be

	rcsci -b -nKUDO&lowbar;STATISTICS foo.c
		where KUDO&lowbar;STATISTICS is a symbolic name of branch
	* This command will create a branch named KUDO&lowbar;STATISTICS
	  off the last version on the mainline of foo.c

If you would like to specify the version number of which the first
branch element is off, a command would be

	rcsci -b -r1.2 -nKUDO&lowbar;STATISTICS foo.c
		where 1.2 is the version number of which the first
		branch element is off


The name is assigned to the branch (not the branched element), so
the subsequent commands such as 

	rcsco -l -rKUDO&lowbar;STATISTICS foo.c

will refer to the latest element in that line of development.


3. What I checked in using branch

I checked in the following files using branch with the symbolic name
"KUDO&lowbar;STATISTICS".

	vicedep/mond.rpc2
	venus/	fso.h
		fso0.c
		fso1.c
		hdb.c
		sighand.c
		venus.c
		venus.private.h
		venusresov.h
		venusutil.c
		venusvol.c
		venusvol.h
		venusvm.c
		venusvm.h
		vol&lowbar;vsr.c
		vproc.c

The purpose of the modifications is to collect session statistics 
and send them to the mond data collector. Currently, venii built 
with these files are running on Brahms and faust, safely (I think so). 

</verb></tscreen>

<sect>Coding Tips<p>
&lsqb;<em>to be written</em>&rsqb;
