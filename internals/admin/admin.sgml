<!doctype linuxdoc SYSTEM "../../dtd/linuxdoc.dtd" [

<!entity % latex "INCLUDE">
<!entity % html  "IGNORE">
<![ %latex; [ <!entity newpage PI "\newpage"> ]]>
<![ %html; [ <!entity newpage PI "<HR>"> ]]>
<!entity newpage PI "">
]>

<article>



<title> The Venus kernel interface
<author> Peter J. Braam and  Henry M. Pierce
<date>v1.1, Nov 9, 1997

<abstract> This document describes the current implementation of the
Coda system administration, it's problems and ideas for future design.
</abstract>

<toc>
&newpage;<sect> Introduction <P> 

A key component in the Coda Distributed File System is the cache
manager, <em>Venus</em>.  

<figure>
  <eps file="interfaces" height="7cm">
  <caption><label id="fig_overview">Interfaces of Coda FS Driver
</figure>


&newpage;<sect> The message layer <p>  

At the lowest level the communication between Venus and the FS driver
proceeds through messages.  The synchronization of between processes
requesting Coda file service and Venus relies on blocking and waking
up processes.  The Coda FS driver processes VFS- and pioctl-requests
on behalf of a process P, creates messages for Venus, awaits replies
and finally returns to the caller.  The implementation of the exchange
of messages is platform specific, but the semantics have (so far)
appeared to be generally applicable.  Data buffers are created by the
FS Driver in kernel memory on behalf of P and copied to user memory in
Venus.


<itemize>

<item> the message is a reply for a suspended thread P.  If so it
removes the message from the processing queue and marks the message as
WRITTEN.  Finally, the FS driver unblocks P (still in the kernel mode
context of Venus) and the <tt>sendmsg_to_kernel</tt> call returns to
Venus.  The process P will be scheduled at some point and continues
processing its <tt/upcall/ with the data buffer replaced with the
reply from Venus.

<item> The message is a <em>downcall</em>.  A downcall is a request
from Venus to the FS Driver. The FS driver processes the request
immediately (usually a cach eviction or replacement) and when finishes
<tt/sendmsg_to_kernel/ returns.
</itemize>

Now P awakes and continues processing <tt/upcall/.  There are some
subtleties to take account off. First P will determine if it was woken
up in <tt/upcall/ by a signal from some other source (for example an
attempt to terminate P) or as is normally the case by Venus in its
<tt/sendmsg_to_kernel/ call.  In the normal case, the upcall routine
will deallocate message structure and return.  The FS routine can
proceed with its processing.


<figure>
  <eps file="sleep">
  <caption><label id="ServerOrg"> Sleeping and IPC arrangements
</figure>



<sect1> Implementation details <p>
The Unix implementation of this mechanism has been through the
implemenation of a character device associated with Coda.  Venus
retrieves messages by doing a <tt/read/ on the device, replies are
sent with a <tt/write/ and notification is through the <tt/select/
system call on the file descriptor for the device.  The process P is
kept waiting on an interruptible wait queue object.

This section describes the upcalls a Coda FS driver can make to
Venus.  Each of these upcalls make use of two structures: <tt>
inputArgs</tt> and <tt/outputArgs/.   In pseudo BNF form the
structures take the following form:

<verb>
struct inputArgs {
    u_long opcode;
    u_long unique;     /* Keep multiple outstanding msgs distinct */
    u_short pid;		 /* Common to all */
    u_short pgid;		 /* Common to all */
    struct CodaCred cred;	 /* Common to all */
    
    <union "in" of call dependent parts of inputArgs>
};
</verb>

<descrip>
<tag/in/ 
<verb>
	struct  cfs_lookup_in {
	    ViceFid	VFid;
	    char        *name;		/* Place holder for data. */
	} cfs_lookup;
</verb>
<tag/out/ 
<verb>
	struct cfs_lookup_out {
	    ViceFid VFid;
	    int	vtype;
	} cfs_lookup;
</verb>
</descrip>

</article>