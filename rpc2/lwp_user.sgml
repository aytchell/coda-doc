<label id="LWPPart">

<chapt>Chapter(The Basic LWP Package)<P>
<label id="LWPReference"><p>
The LWP package implements primitive functions providing basic
facilities that enable procedures written in C, to proceed in an
unsynchronized fashion.  These separate threads of control may
effectively progress in parallel, and more or less independently of
each other.  This facility is meant to be general purpose with a heavy
emphasis on simplicity.  Interprocess communication facilities can be
built on top of this basic mechanism, and, in fact, many different IPC
mechanisms could be implemented.  The RPC2 remote procedure call
package (also described in this manual) is one such IPC mechanism.


The LWP package makes the following key design choices:
<itemize>
  <item>The package should be small and fast;

  <item>All processes are assumed to be trustworthy -- processes are not protected
from each others actions;

  <item>There is no time slicing or preemption -- the processor must be yielded
explicitly.
</itemize>

In order to set up the environment needed by the lightweight process
support, a one-time invocation of the LWP_Init function must
precede the use of the facilities described here.  The initialization
function carves an initial process out of the currently executing C
procedure.  The process id of this initial process is returned as the
result of the LWP_Init function.  For symmetry a
LWP_TerminateProcessSupport function may be used explicitly to
release any storage allocated by its initial counterpart.  If used, it
must be issued from the process created by the LWP_Init function. <p>

Upon completion of any of the lightweight process
functions, an integer value is returned to indicate whether any error
conditions were encountered.<p>

Macros, typedefs, and manifest constants for error codes needed by the
lightweight process mechanism reside in the file <tt>&lt;lwp.h&gt;</tt> (shown
in Appendix <ref id="lwp.h)" name="XXX">.
A process is identified by an object of type PROCESS, which is
defined in the include file. <p>

The process model supported by the operations described here
is based on a non-preemptive priority dispatching scheme. (A priority is an integer in the range &lsqb;0..LWP&lowbar;MAX&lowbar;PRIORITY&rsqb;,
where 0 is the lowest priority.)
Once a given lightweight process is selected and dispatched, it
remains in control until it voluntarily relinquishes its claim
on the CPU.
Relinquishment may be either explicit (LWP_DispatchProcess) or
implicit (through the use of certain other LWP operations).
In general, all LWP operations that may cause a
higher priority process to become ready for dispatching,
preempt the process requesting the service.
When this occurs, the priority dispatching mechanism takes over and
dispatches the highest priority process automatically.  Services in this
category (where the scheduler is guaranteed to be invoked in the absence of
errors) are

<itemize>
<item>LWP_CreateProcess
<item>LWP_WaitProcess
<item>LWP_MwaitProcess
<item>LWP_SignalProcess
<item>LWP_DispatchProcess
<item>LWP_DestroyProcess
</itemize>

The following services are guaranteed not to cause preemption (and so may be issued with no fear of losing control to another
lightweight process):
<itemize>
<item>LWP_Init
<item>LWP_NoYieldSignal
<item>LWP_CurrentProcess
<item>LWP_StackUsed
<item>LWP_NewRock
<item>LWP_GetRock
</itemize>

The symbol LWP&lowbar;NORMAL&lowbar;PRIORITY provides a good default value to
use for process priorities.

<sect>A word about initialization<p>
The LWP, IOMGR, Fast Time, and RPC2 packages have routines that
perform global initialization for the package.  Each of these routines
may be called more than once, and only the parameters from the first
invocation will be used.  In addition, each routine calls any of the
others that it needs for proper operation.

The result is that if you only use one package directly, you need only
call the initialization routine for that package.  You may call the
initialization routines for other packages anyway in order to set the
initialization parameters yourself.  If you wish to initialize all of
these packages yourself, you must call the initialization routines in
this order: Fast Time, LWP, IOMGR, RPC2.  The RPC2 package does not
call the LWP packages initialization routine.  You must call
LWP_Init explicitly before calling RPC2_Init.

In contrast, the Preemption package initialization routine may be
called multiple times to change the value of the preemption time
slice.

The Lock and Timer packages have initialization routines that initialize
objects instead of global data.  The only restriction on the order of the
initialization calls to these packages is that calls to TM_Init must
follow your call to FT_Init, if you have one.


<sect>A Simple Example<p>

<tscreen><verb>

#include &lt;lwp.h&gt;

static read_process (id)
    int *id;
{
    LWP_DispatchProcess ();		/* Just relinquish control for now */

    for (;;) {
	/* Wait until there is something in the queue */
	while (empty(q)) LWP_WaitProcess (q);
	/* Process queue entry */
	LWP_DispatchProcess ();
   }
}

static write_process ()
{
    . . .

    /* Loop & write data to queue */
    for (mesg=messages; *mesg!=0; mesg++) &lcub;
	insert (q, *mesg);
	LWP_SignalProcess (q);
    }
}

main (argc, argv)
   int argc; char **argv;
{
    PROCESS *id;

    LWP_Init (LWP&lowbar;VERSION, 0, &amp;id);
    /* Now create readers */
    for (i=0; i < nreaders; i++)
	LWP_CreateProcess (read_process, STACK_SIZE, 0, i, "Reader", &amp;readers&lsqb;i&rsqb;);
    LWP_CreateProcess (write_process, STACK_SIZE, 1, 0, "Writer", &amp;writer);
    /* Wait for processes to terminate */
    LWP_WaitProcess (&amp;done);
    for (i=nreaders-1; i&gt;=0; i--) LWP_DestroyProcess (readers&lsqb;i&rsqb;);
&rcub;
@end(program)
main (argc, argv)
   int argc; char **argv;
&lcub;
    PROCESS *id;

    LWP_Init (LWP_VERSION, 0, &amp;id);
    /* Now create readers */
    for (i=0; i&lt; nreaders; i++)
	LWP_CreateProcess (read_process, STACK_SIZE, 0, i, "Reader", &amp;readers&lsqb;i&rsqb;);
    LWP_CreateProcess (write_process, STACK_SIZE, 1, 0, "Writer", &amp;writer);
    /* Wait for processes to terminate */
    LWP_WaitProcess (&amp;done);
    for (i=nreaders-1; i&gt;=0; i--) LWP_DestroyProcess (readers&lsqb;i&rsqb;);
&rcub;

</verb></tscreen>

<sect>LWP Runtime Calls<p>
<sect1> LWP_Init -- <em> Initialize LWP support and start initial process</em><p>
  <sect2>Call:<p>
    <em>int LWP_Init(</em><bf>in</bf> char *VersionId&gt;, @w&lt;<bf>in</bf> int priority&gt;, @w&lt;<bf>out</bf> PROCESS *pid&gt;)
  <sect2>Parameters:<p>
    <descrip>
	<tag/VersionId/Set this to the constant LWP_VERSION.  The current value of this string  constant must be identical to the value at the time the client runtime system was compiled.
	<tag/priority/Priority at which initial process is to run.
	<tag/pid/The process id of the initial process will be returned in this parameter.
  </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
	<tag/LWP_SUCCESS/All went well
	<tag/LWP_EBADPRI/Illegal priority specified (&lt; 0 or too large)
    </descrip>
  <sect2>Description:<p>
    Initializes the LWP package.  In addition, this routine turns the current thread of control into the initial process with the specified priority.  The process id
	      of this initial process will be returned in parameter pid. This routine must be
	      called to ensure proper initialization of the LWP routines.  This routine will
	      not cause the scheduler to be invoked.
)

<sect1>LWP_TerminateProcessSupport -- Terminate process support and clean up
  <sect2>Call:<p>
     <em>int LWP_TerminateProcessSupport()</em>
  <sect2>Parameters:<p>
     <em/none./
  <sect2>Completion Codes:<P>
     <em>N/A</em>
  <sect2>Description:<p>
      This routine will terminate the LWP process support and clean
	     up by freeing any auxiliary storage used.  This routine must be
	     called from within the procedure and process that invoked
	     LWP_Init.  After
	     LWP_TerminateProcessSupport has been called,
	     LWP_Init may be called again to resume
	     LWP process support.
)

<sect1>LWP_CreateProcess -- Create and start a light-weight process<p>
  <sect2>Call:<p>
    <em>int LWP_CreateProcess(</em><bf>in</bf> int (*ep) (),<bf>in</bf> int stacksize,<bf>in</bf> int priority, <bf>in</bf> char *parm <bf>in</bf> char *name, <bf>out</bf> PROCESS *pid)
  <sect2>Parameters:<p>
    <descrip>
	<tag/ep/This is the address of the code that is to execute the function
	     of this process.  This parameter should be the address
	     of a C routine with a single parameter.,
	<tag/stacksize/
	This is the size (in bytes) to make the stack for the
	     newly-created process.  The stack cannot be shrunk or expanded,
	     it is fixed for the life of the process.,
	<tag/priority/
	This is the priority to assign to the new process.,
	<tag/parm/
	This is the single argument that will be passed to the new
	     process.  Note that this argument is a pointer and, in general,
	     will be used to pass the address of a structure containing
	     further "parameters".,
	<tag/name/
	This is an ASCII string that will be used for debugging purposes
	     to identify the process.  The name may be a maximum of 32
	     characters.,
	<tag/pid/
	The process id of the new process will be returned in this
	     parameter,
    </descrip>
  <sect2>Completion Codes:<P>
    <descrip>
	<tag/LWP_SUCCESS/Process created successfully,
	<tag/LWP_ENOMEM/Not enough free space to create process,
	<tag/LWP_EBADPRI/Illegal priority specified (&lt; 0 or too large),
	<tag/LWP_EINIT/LWP_Init has not been called
    </descrip>
	This routine is used to create and mark as runnable a new light-weight
	     process.  This routine will cause the scheduler to be called.
	     Note that the new process will begin execution before this call
	     returns only if the priority of the new process is greater than
	     or equal to the priority of the creating process.
)

<sect1>LWP_DestroyProcess -- Destroy a light-weight process<p>
  <sect2>Call:<p>
    <em> int LWP_DestroyProcess(</em><bf>in</bf> PROCESS pid)
  <sect2>Parameters:<p>
    <descrip>
      <tag/pid/The process id of the process to be destroyed.
    </descrip>
  <sect2>Completion Codes:<P>
    <descrip>
        <tag/LWP_SUCCESS/ Process destroyed successfully
	<tag/LWP_EINIT/ LWP_Init has not been called
    </descrip>
  <sect2>Description:<p>
             This routine will destroy the specified process.  The
	     specified process will be terminated immediately and its
	     internal storage will be freed.  A process is allowed to
	     destroy itself (of course, it will only get to see the return
	     code if the destroy fails).  Note a process may also destroy
	     itself by executing a <bf>return</bf> from the C routine.  This routine
	     calls the scheduler.

<sect1>LWP_WaitProcess -- Wait for event<p>
  <sect2>Call:<p>
    <em>int LWP_WaitProcess(</em><bf>in</bf> char *event)
  <sect2>Parameters:<p>
    <descrip>
      <tag/event/The event to wait for.  This can be any memory address.  But, 0 is an
	     illegal event.
    </descrip>
  <sect2>Completion Codes:<P>
    <descrip>
      <tag/LWP_SUCCESS/The event has occurred
      <tag/LWP_EINIT/LWP_Init has not been
	     called
      <tag/LWP_EBADEVENT/The specified event was illegal (0)
    </descrip>
  <sect2>Description:<p>
	This routine will put the calling process to sleep until
	     another process does a call of LWP_SignalProcess or LWP_NoYieldSignal with the
	     specified event.  Note that signals of events are not queued:
	     if a signal occurs and no process is woken up, the signal is
	     lost.  This routine invokes the scheduler. 
)

<sect1>LWP_MwaitProcess -- Wait for a specified number of a group of signals
  <sect2>Call:<p>
    <em>int LWP_MwaitProcess(</em><bf>in</bf> int wcount, <bf>in</bf> char *evlist)
  <sect2>Parameters:<p>
    <descrip>
      <tag/wcount/
	Is the number of events that must be signaled to wake up this
	     process
      <tag/evlist/
	This a null-terminated list of events (remember that 0 is not a
	     legal event).  There may be at most LWP_MAX_EVENTS events
    </descrip>
  <sect2>Completion Codes:<P>
    <descrip>
	<tag/LWP_SUCCESS/The specified number of appropriate
	     signals has occurred
	<tag/LWP_EBADCOUNT/There are too few events (0)
	     or wcount &gt; the number of events in evlist
	<tag/LWP_EINIT/LWP_Init has not been
	     called
    </descrip>
  <sect2>Description:<p>
	This routine allows a process to wait for wcount signals of
	     any of the signals in evlist.  Any number of signals of a
	     particular event is only counted once.  The scheduler will be
	     invoked.
)

<sect1>LWP_SignalProcess -- Signal an event<p>
  <sect2>Call:<p>
    <em>int LWP_SignalProcess(</em><bf>in</bf> char *event)
  <sect2>Parameters:<p>
    <descrip>
       <tag/event/
	The event to be signaled.  An event is any memory address
	     except 0
    </descrip>
  <sect2>Completion Codes:<P>
    <descrip>
	<tag/LWP_SUCCESS/ The signal was a success (a process was
	     waiting for it)
	<tag/LWP_EBADEVENT/ The specified event was illegal (0),
	<tag/LWP_EINIT/ LWP_Init was not
	     called,
	<tag/LWP_ENOWAIT/ No process was waiting for this signal,
    </descrip>
  <sect2>Description:<p>
	This routine causes event to be signaled.  This will mark all
	     processes waiting for only this event as runnable.  The
	     scheduler will be invoked.  Signals are not queued: if no
	     process is waiting for this event, the signal will be lost and
	     LWP_ENOWAIT will be returned.
)

<sect1>   What call is thore for. <P>
  
  <sect2>Parameters:<p>
    <descrip>
	<tag/event
	/The event to be signaled.  An event is any memory address
	     except 0,
    </descrip>
  <sect2>Completion Codes:<P>
    <descrip>
	<tag/LWP_SUCCESS/The signal was a success (a process was
	     waiting for it),
	<tag/LWP_EBADEVENT/The specified event was illegal (0),
	<tag/LWP_EINIT/LWP_Init was not
	     called,
    </descrip>
  <sect2>Description:<p>
	Text=`This routine causes event to be signaled.  This will mark all
	     processes waiting for only this event as runnable.  This call
	     is identical to LWP_SignalProcess except that the scheduler
	     will not be invoked -- control will remain with the signalling process.
	     Signals are not queued: if no process is waiting for this event, the signal
	     will be lost and LWP_ENOWAIT will be returned.
)

<sect1> LWP_XXXFIXME
  
  <sect2>Parameters:<p>
Well??

  <sect2>Completion Codes:<P>
    <descrip>
	<tag/LWP_SUCCESS/All went well,
	<tag/LWP_EINIT/LWP_Init has not been
	     called,
    </descrip>
  <sect2>Description:<p>
	Text=`This routine is a voluntary yield to the LWP scheduler.

<sect1>LWP_CurrentProcess -- Get the current process id
  <sect2>Call:<p>
    <em>int LWP_CurrentProcess(</em><bf>out</bf> PROCESS *pid)
  <sect2>Parameters:<p>
    <descrip>
	<tag/pid,
	/The current process id will be returned in this parameter
    </descrip>
  <sect2>Completion Codes:<P>
    <descrip>
        <tag/LWP_SUCCESS/The current process id has been returned,
	<tag/LWP_EINIT/LWP_Init has not been
	     called,
    </descrip>
  <sect2>Description:<p>
	Text=`This routine will place the current process id in the
	     parameter pid.
)

<sect1>LWP_StackUsed -- Get information about stack usage for a process
  <sect2>Call:<p>
    <em>int LWP_StackUsed(</em><bf>in</bf> PROCESS pid<bf>out</bf> int *max<bf>out</bf> int *used)
  <sect2>Parameters:<p>
    <descrip>
	<tag/pid/ The target process
	<tag/max/ Max stack size given at process creation time
	<tag/used/ Stack used so far
    </descrip>
  <sect2>Completion Codes:<P>
    <descrip>
	<tag/LWP_SUCCESS/No problem,
	<tag/LWP_NO_STACK/Stack counting was not enabled for this
		process.,
    </descrip>
  <sect2>Description:<p>
	Text=`This routine returns the amount of stack space allocated to
	      the process and the amount actually used by the process so
	      far.  It works by initializing the stack to a special pattern
	      at process creation time and checking to see how much of the
	      pattern is still there when <bf>LWP_StackUsed</bf> is called.
	      The stack of the process is only initialized to the special
	      pattern if the global variable <bf>lwp_stackUseEnabled</bf> is
	      true when the process is created.  This variable is initially
	      true.  If <bf>lwp_stackUseEnabled</bf> was false at the time the
	      process was created, then <bf>*used</bf> will be set to zero
	      and the routine will return <bf>LWP_NO_STACK</bf>.
)

<sect1>LWP_NewRock -- Find a rock under which private information can be hidden
  <sect2>
    <em>int LWP_NewRock(</em><bf>in</bf> int Tag <bf>in</bf> char *Value)
  <sect2>Parameters:<p>
    <descrip>
      <tag/Tag/ A unique integer identifying this rock.
      <tag/Value/ A value (usually a pointer to some data structure) to be associated with the current LWP and identified by Tag.
    </descrip>
  <sect2>Completion Codes:<P>
    <descrip>
	<tag/LWP_SUCCESS/No problem.
	<tag/LWP_EBADROCK/Rock called Tag already exists for this LWP.
	<tag/LWP_ENOROCKS/All rocks are in use.
    </descrip>
  <sect2>Description:<p>
	Text=`The rock is exactly what its name implies: a place to squirrel away application-specific
		information associated with an LWP.  The Tag is any unique integer.
		Users of the LWP package must coordinate their choice of Tag values.
		Note that you cannot change the value associated with Tag.  To obtain
		a mutable data structure use one level of indirection.
)

<sect1>LWP_GetRock -- Obtain information hidden under a rock
  <sect2>Call:<p>
    <em>int LWP_GetRock(</em><bf>in</bf> int Tag, <bf>out</bf> char **Value)
  <sect2>Parameters:<p>
    <descrip>
	<tag/Tag/Rock under which to look.,
	<tag/Value/The current value (usually a pointer to some data structure) hidden under this rock.
    </descrip>
  <sect2>Completion Codes:<P>
    <descrip>
	<tag/LWP_SUCCESS/Value has been filled.,
	<tag/LWP_EBADROCK/Specified rock does not exist.,
    </descrip>
  <sect2>Description:<p>
	Text=`Recovers information hidden by a LWP_NewRock call.

<Chapt>The Lock Package<P>
<label id="LockPackage">

The lock package contains a number of routines and macros that allow C
programs that utilize the LWP abstraction to place read and write locks on
data structures shared by several light-weight processes.
Like the LWP package, the lock package was written with simplicity in mind
-- there is no protection inherent in the model.

In order to use the locking mechanism for an object, an object of type
<tt>struct Lock</tt> must be associated with the object.
After being initialized, with a call to @Lock(Init), the lock is used
in invocations of the macros ObtainReadLock,
ObtainWriteLock, ReleaseReadLock and ReleaseWriteLock.

The semantics of a lock is such that any number of readers may hold a lock.
But only a single writer (and no readers) may hold the clock at any time.
The lock package guarantees fairness: each reader and writer will eventually
have a chance to obtain a given lock.
However, this fairness is only guaranteed if the priorities of the competing
processes are identical.
Note that no ordering is guaranteed by the package.

In addition, it is illegal for a process to request a particular lock more
than once, without first releasing it.
Failure to obey this restriction may cause deadlock.

<sect>Key Design Choices<p>
<itemize>
  <item>The package must be simple and @u&lsqb;fast&rsqb;: in the case that a lock can be
  <item>obtained immediately, it should require a minimum of instructions;

  <item>All the processes using a lock are trustworthy;

  <item>The lock routines ignore priorities;
</itemize>


<sect1>A Simple Example<p>
@Begin(program)
#include "lock.h"

struct Vnode &lcub;
    . . .
    struct Lock	lock;	/* Used to lock this vnode */
    . . .
&rcub;;

#define READ	0
#define WRITE	1

struct Vnode *get_vnode (name, how)
    char *name;
    int how;
&lcub;
    struct Vnode *v;

    v = lookup (name);
    if (how == READ)
	ObtainReadLock (&amp;v-&gt; lock);
    else
	ObtainWriteLock (&amp;v-&gt; lock);
&rcub;
@End(program)


<sect>Lock Primitives<p>
<sect1> Lock_Init -- Initialize a lock <p>
  <sect2>Call:<p>
    <em> void Lock_Init(</em> @w&lt;<bf>out</bf> struct Lock *lock&gt; <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      <tag/lock/The (address of the) lock to be initialized,
    </descrip>
  <sect2>Completion Codes:<p>
      <em> N/A </em>
  <sect2>Description:<p>
       This routine must be called to initialize a lock before it is
	     used.


<sect1> ObtainReadLock -- Obtain a read lock <p>
  <sect2>Call:<p>
    <em> ObtainReadLock(</em> @w&lt;<bf>in out</bf> struct Lock *lock&gt; <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      <tag/lock/The lock to be read-locked,
    </descrip>
  <sect2>Completion Codes:<p>
      <em> N/A </em>
  <sect2>Description:<p>
	     A read lock will be obtained on the specified lock.  Note that
	     this is a macro and not a routine.  Thus, results are not
	     guaranteed if the lock argument is a side-effect producing
	     expression.

<sect1> ObtainWriteLock -- Obtain a write lock <p>
  <sect2>Call:<p>
    <em> ObtainWriteLock(</em> @w&lt;<bf>in out</bf> struct Lock *lock&gt; <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      	<tag/lock/The lock to be write-locked
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
         <em> N/A </em>
    </descrip>
  <sect2>Description:<p>
	     A write lock will be obtained on the specified lock.  Note that
	     this is a macro and not a routine.  Thus, results are not
	     guaranteed if the lock argument is a side-effect producing
	     expression.
)

<sect1> ReleaseReadLock -- Release a read lock <p>
  <sect2>Call:<p>
    <em> ReleaseReadLock(</em> @w&lt;<bf>in out</bf> struct Lock *lock&gt; <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      <tag/lock/The lock to be released
    </descrip>
  <sect2>Completion Codes:<p>
      <em>N/A </em>
  <sect2>Description:<p>
	     The specified lock will be released.  This macro requires that
	     the lock must have been previously read-locked.  Note that
	     this is a macro and not a routine.  Thus, results are not
	     guaranteed if the lock argument is a side-effect producing
	     expression.

<sect1> ReleaseWriteLock -- Release a write lock <p>
  <sect2>Call:<p>
    <em> ReleaseWriteLock(</em> @w&lt;<bf>in out</bf> struct Lock *lock&gt; <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      <tag/lock/The lock to be released
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
       <em>N/A </em>
    </descrip>
  <sect2>Description:<p>
	     The specified lock will be released.  This macro requires that
	     the lock must have been previously write-locked.  Note that
	     this is a macro and not a routine.  Thus, results are not
	     guaranteed if the lock argument is a side-effect producing
	     expression.
)

<sect1> CheckLock -- Check the status of a lock <p>
  <sect2>Call:<p>
    <em> CheckLock(</em> @w&lt;<bf>in</bf> struct Lock *lock&gt; <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      <tag/lock/The lock to be checked
    </descrip>
  <sect2>Completion Codes:<p>
      <em> N/A </em>
  <sect2>Description:<p>
	     This macro yields an integer that specifies the status of the
	     indicated lock.  The value will be -1 if the lock is write-locked
	     0 if unlocked, or a positive integer that indicates the numer
	     of readers with read locks.  Note that this is a macro and not a
	      routine.  Thus, results are not guaranteed if the lock argument
	      is a side-effect producing expression.
)

<Chapt>The IOMGR Package<P>
<label id="IOMGRPrimitives">

The IOMGR package allows light-weight processes to wait on various Unix
events.  IOMGR_Select allows a light-weight process to wait on the same
set of events that the Unix <tt>select</tt> call waits on.  The parameters to
these routines are the same.  IOMGR_Select puts the caller to sleep
until no user processes are active.  At this time the IOMGR process, which
runs at the lowest priority, wakes up and coaleses all of the select request
together.  It then performs a single <tt>select</tt> and wakes up all processes
affected by the result.

The IOMGR_Signal call allows a light-weight process to wait on delivery
of a Unix signal.  The IOMGR installs a signal handler to catch all
deliveries of the Unix signal.  This signal handler posts information about
the signal delivery to a global data structure.  The next time that the
IOMGR process runs, it delivers the signal to any waiting light-weight
processes.

<sect>Key Design Choices<p>
<itemize>
  <item>The meanings of the parameters to IOMGR_Select, both before and after
the call, should be identical to those of the Unix <tt>select</tt>;

  <item>A blocking select should only be done if no other processes are runnable.
</itemize>

<sect>A Simple Example<p>
<tscreen> <verb>
void rpc2_SocketListener ()
&lcub;
    int ReadfdMask, WritefdMask, ExceptfdMask, rc;
    struct timeval *tvp;

    while (TRUE) &lcub;
	. . .
	ExceptfdMask = ReadfdMask = (1 &lt;&lt; rpc2_RequestSocket);
	WritefdMask = 0;
	rc = IOMGR_Select (8*sizeof(int), &amp;ReadfdMask, &amp;WritefdMask, &amp;ExceptfdMask, tvp);

	switch (rc) &lcub;
	    case 0:	/* timeout */
		    continue;	/* main while loop */
		    
	    case -1:	/* error */
		    SystemError ("IOMGR_Select");
		    exit (-1);
		    
	    case 1:	/* packet on rpc2_RequestSocket */
		    . . . process packet . . .
		    break;

	    default:	/* should never occur */
	&rcub;
    &rcub;
&rcub;
</verb></tscreen>

<sect>IOMGR Primitives<p>

<sect1> IOMGR_Initialize -- Initialize the IOMGR package <p>
  <sect2>Call:<p>
    <em> void IOMGR_Initialize(</em>  <em>)</em>
  </sect2>  <sect2>Parameters:<p>
      <em> None. </em>
  <sect2>Completion Codes:<p>
    <descrip>
      	<tag/LWP_SUCCESS/All went well,
	<tag/LWP_ENOMEM/Not enough free space to create the IOMGR
	    process,
	<tag/-1/Something went wrong with other init calls,
    </descrip>
  <sect2>Description:<p>
	     This call will initialize the IOMGR package.  Its main task is
	     to create the IOMGR process, which runs at priority 0, the
	     lowest priority.  The remainder of the processes must be
	     running at priority 1 or greater for the IOMGR package to
	     function correctly.
)

<sect1> IOMGR_Finalize -- Clean up after IOMGR package <p>
  <sect2>Call:<p>
    <em> void IOMGR_Finalize(</em> , <em>)</em>
  </sect2>  <sect2>Parameters:<p>
      <em> None. </em>
  <sect2>Completion Codes:<p>
    <descrip>
      	<tag/LWP_SUCCESS/Package finalized okay,
    </descrip>
  <sect2>Description:<p>
             This call cleans up when the IOMGR package is no longer
	     needed.  It releases all storage and destroys the IOMGR
	     process.

<sect1>  --  <p>
  <sect2>Call:<p>
    <em>  (</em>  <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      
    </descrip>
  <sect2>Description:<p>

<sect1> IOMGR_Select -- Perform an LWP select operation <p>
  <sect2>Call:<p>
    <em>  IOMGR_Select(</em> @w&lt;<bf>in</bf> int fds&gt;, @w&lt;<bf>in out</bf> int *readfds&gt;, @w&lt;<bf>in out</bf> *writefds&gt;, <em>)</em>
  </sect2>  
  <sect2>Parameters:<p>
    <descrip>
	<tag/fds/Maximum number of bits to consider in masks,
	<tag/readfds/Mask of file descriptors that process wants notification of
	    when ready to be read,
	<tag/writefds/Mask of file descriptors that process wants notification of
	    when ready to be written,
	<tag/exceptfds/Mask of file descriptors that process wants notification of
	    when exceptional condition occurs,
	<tag/timeout/Timeout for use on this selectrip>
    </descrip>
  <sect2>Completion Codes:<p>
  <sect2>Description:<p>
             This function performs an LWP version of Unix <bf>select</bf>.  The
	     parameters have the same meanings as the Unix call.  However,
	     the return value will only be -1 (an error occurred), 0 (a timeout occurred),
	     or 1 (some number of file descriptors are ready).  If this is
	     a polling select, it is done and IOMGR_;Select returns to
	     the user with the results.  Otherwise, the calling process is
	     put to sleep.  If at some point, the IOMGR process is the only
	     runnable process, it will awaken and collect all select
	     requests.  It will then perform a single select and awaken
	     those processes the appropriate processes -- this will cause
	     return from the affected IOMGR_;selects.


<sect1> IOMGR_Signal -- Convert Unix signals to LWP signals <p>
  <sect2>Call:<p>
    <em>  IOMGR_Signal(</em> @w&lt;<bf>in</bf> int signo&gt;, @w&lt;<bf>in</bf> char *event&gt;, <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      	<tag/signo/The unix signal number, as defined in signal.h,
	<tag/event/The light-weight process event that should be signaled whenever
	    <em>signo</em> is delivered
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      	<tag/LWP_;SUCCESS/No problems.,
	<tag/LWP_;EBADSIG/<em>signo</em> was out of range,
	<tag/LWP_;EBADEVENT/<em>event</em> was zero,
    </descrip>
  <sect2>Description:<p>
             This function associates an LWP signal with a Unix signal.
	     When the Unix signal <em>signo</em> is delivered to the
	     process, the IOMGR process will deliver an LWP signal to the
	     event <em>event</em> via LWP_;NoYieldSignal,
	     waking any light-weight processes waiting
	     on that event.  Multiple deliveries of the signal may be
	     coalesed into one LWP wakeup.  The call to LWP_;NoYieldSignal
	     will happen synchronously.  It is safe for an LWP to check for
	     some condition and then go to sleep waiting for a Unix signal
	     without having to worry about delivery of the signal happening
	     between the check and the call to LWP_;WaitProcess.

<sect1> IOMGR_;CancelSignal -- Cancel association between Unix signal and LWP event <p>
  <sect2>Call:<p>
    <em>  IOMGR_;CancelSignal(</em> @w&lt;<bf>in</bf> int signo&gt;, <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      	<tag/signo/The Unix signal that should no longer be converted.
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      	<tag/LWP_;SUCCESS/The association was cancelled,
	<tag/LWP_;EBADSIG/<em>signo</em> is out of range or
		LWP_Signal has not been called on it,
    </descrip>
  <sect2>Description:<p>
            This function cancels the association of a Unix signal and an
	    LWP event.  After calling this function, the Unix signal
	     <em>signo</em> will be handled however it was handled before the
	     corresponding call to LWP_Signal.



<Chapt>The Timer Package<P>
<label id="TMPackage">

The timer package contains a number of routines that assist in manipulating
lists of objects of type <tt>struct TM_Elem</tt>.
TM_Elems (timers) are assigned a timeout value by the user and inserted in a
package-maintained list.
The time remaining to timeout for each timer is kept up to date by the
package under user control.
There are routines to remove a timer from its list, to return an expired
timer from a list and to return the next timer to expire.
This specialized package is currently used by the IOMGR package and by the
implementation of RPC2.
A timer is used commonly by inserting a field of type <tt>struct TM_Elem</tt>
into a structure.
After inserting the desired timeout value the structure is inserted into a
list, by means of its timer field.

<sect>A Simple Example<p>

<tscreen> <verb>
static struct TM_Elem *requests;

. . .

    TM_Init (&amp;requests);        /* Initialize timer list */
    . . .
    for (;;) &lcub;
        TM_Rescan (requests);   /* Update the timers */
        expired = TM_GetExpired (requests);
        if (expired == 0) break;
        . . . process expired element . . .
    &rcub;
</verb>
</tscreen> 

<sect1>Timer Primitives<p>

<sect1> TM_Init -- Initialize a timer list <p>
  <sect2>Call:<p>
    <em> void TM_Init(</em> @w&lt;<bf>out</bf> struct TM_Elem **list&gt;, <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      <tag/list/The list to be initialized
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      	<tag/0/ok,
	<tag/-1/not enough free storage
    </descrip>
  <sect2>Description:<p>
	     The specified list will be initialized so that it is an empty
	     timer list.  This routine must be called before any other
	     operations are applied to the list.
)

<sect1> TM_Final -- Finalize a timer list <p>
  <sect2>Call:<p>
    <em> void TM_Final(</em> @w&lt;<bf>out</bf> struct TM_Elem **list&gt;, <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      <tag/list/The list to be finalized
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      	<tag/0/ok,
	<tag/-1/*list was 0 or list was never initialized
    </descrip>
  <sect2>Description:<p>
	     Call this routine when you are finished with a timer list and
	     the list is empty.  This routine releases any auxiliary storage
	     associated with the list.
)

<sect1> TM_Insert -- Release a read lock, <p>
  <sect2>Call:<p>
    <em> void TM_Insert(</em> <bf>in</bf> struct TM_Elem *list&gt;, @w&lt;<bf>in out</bf> struct TM_Elem *elem <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      	<tag/list/The list into which the element is to be inserted
	<tag/elem/The element to be initialized and inserted
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
             The element <em>elem</em> is initialized so that the <em>TimeLeft</em>
	     field is equal to the <em>TotalTime</em> field.  (The <em>TimeLeft</em>
	     field may be kept current by use of TM_Rescan.)  The
	     element is then inserted into the list.
    </descrip>
  <sect2>Description:<p>
            The element <em>elem</em> is initialized so that the <em>TimeLeft</em>
	     field is equal to the <em>TotalTime</em> field.  (The <em>TimeLeft</em>
	     field may be kept current by use of TM_Rescan.)  The
	     element is then inserted into the list.
)

<sect1> TM_Rescan -- Update <em>TimeLeft</em> fields of entries on a timer list and look for expired elements<p>
  <sect2>Call:<p>
    <em> void TM_Rescan(</em> @w&lt;<bf>out</bf> struct TM_Elem **list&gt;, <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      <tag/list/The list to be updated
    </descrip>
  <sect2>Completion Codes:<p>
  <sect2>Description:<p>
	     This routine will update the <em>TimeLeft</em> fields of all timers
	     on <em>list</em>.  (This is done by checking the time of day clock in
	     Unix.)  This routine returns a count of the number of expired
	     timers on the list.  This is the only routine (besides TM_Init
	     that updates the <em>TimeLeft</em> field.
)

@Pascall(Tag=&lt;TMGetExpired&gt;,
	Callname=`TM_GetExpired,
	Abstract=`Return an expired timer from a list,
	Parmlist=`@w&lt;<bf>in</bf> struct TM_Elem *list&gt;,
	Type=`struct TM_Elem *,
    <descrip>
	<tag/list/ The list to be searched,
	Text=`The specified list will be searched and a pointer to an
	     expired timer will be returned.  0 is returned if there are no
	     expired timers.  An expired timer is one whose <em>TimeLeft</em>
	     field is less than or equal to 0.
      )
    </descrip>

<sect1> TM_GetEarliest -- Return the earliest timer on a list<p>
  <sect2>Call:<p>
    <em> void TM_GetEarliest(</em> @w&lt;<bf>out</bf> struct TM_Elem **list&gt;, <em>)</em>
  <sect2>Parameters:<p>
    <descrip>
      	<tag/list/The list to be searched
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      
    </descrip>
  <sect2>Description:<p>
	     This routine returns a pointer to the timer that will be next
	     to expire -- that with a smallest <em>TimeLeft</em> field.  If there
	     are no timers on the list, 0 is returned.
)

<sect1> TM_eql -- See if 2 timevals are equal <p>
  <sect2>Call:<p>
    <em> void TM_eql(</em><bf>in</bf> struct timeval *t1, <bf>in</bf> struct timeval *t2 <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      	<tag/t1/a timeval
	<tag/t2/Another timeval
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      
    </descrip>
  <sect2>Description:<p>
	This routine returns 0 if and only if <em>t1</em> and <em>t2</em> are not equal.

<chapt>The Preemption Package <p>
The preemption package provides a mechanism by which control can pass
between light-weight processes without the need for explicit calls to
LWP_DispatchProcess.
This effect is achieved by periodically interrupting the normal flow
of control to check if other (higher priority) procesess are ready to
run.

The package makes use of the <em>interval timer</em> facilities provided
by 4.2BSD, and so will cause programs that make their own use of
these facilities to malfunction.
In particular, use of <em>alarm (3)</em> or explicit handling of <em>SIGALRM</em>
is disallowed.
Also, calls to <em>sleep (3)</em> may return prematurely.

Care should be taken that routines are re-entrant where necessary.
In particular, note that stdio (3) is not re-entrant in general, and
hence light-weight processes performing I/O on the same FILE structure
may function incorrectly.

<sect>Key Design Choices<p>
<itemize>
The package should not affect the nonpreemptive scheduling behaviour
of processes which do not use it;

It must be simple and @u&lsqb;fast&rsqb;, with a minimum of extra system overhead;

It must support nested critical regions;

Processes using the package are assumed to be <em>co-operating</em>.
</itemize>


<sect>A Simple Example<p>
<tscreen><verb>
#include &lt;sys/time.h&gt;
#include "preempt.h"

	...

	struct timeval tv;

	LWP_Init (LWP_VERSION, ... );
	tv.tv_sec = 10;
	tv.tv_usec = 0;
	PRE_InitPreempt (&amp;tv);
	PRE_PreemptMe ();

	...

	PRE_BeginCritical ();

	...

	PRE_EndCritical ();

	...

	PRE_EndPreempt ();
</verb></tscreen>


<sect>Preemption Primitives<p>

<sect1> PRE_InitPreempt -- Initialize the preemption package, <p>
  <sect2>Call:<p>
    <em> int  PRE_InitPreempt(</em> @w&lt;<bf>in</bf> struct timeval *slice&gt; <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      	<tag/slice/The period of the implicit scheduler calls.  Use NULL to
	     obtain a useful default.
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      	<tag/LWP_SUCCESS/All went well
	<tag/LWP_EINIT/LWP_Init was not
	     called
	<tag/LWP_ESYSTEM/A system call failed
    </descrip>
  <sect2>Description:<p>
	This routine must be called to initialize the package
	     (after the call to LWP_Init).

<sect1> PRE_EndPreempt -- Finalize the preemption package, <p>
  <sect2>Call:<p>
    <em> int  PRE_EndPreempt(</em>  <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
       <em> None </em>
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      	<tag/LWP_SUCCESS/All went well,
	<tag/LWP_EINIT/LWP_Init was not
	     called,
	<tag/LWP_ESYSTEM/A system call failed
    </descrip>
  <sect2>Description:<p>
	     This routine finalizes use of the preemption package.
	     No further preemptions will be made.  Note that is not
	     necessary to make this call before exit - it is provided
	     only for those applications that wish to continue after
	     turning off preemption.
)

<sect1> PRE_PreemptMe -- Mark a process as a candidate for preemption, <p>
  <sect2>Call:<p>
    <em>  PRE_PreemptMe(</em>  <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      
    </descrip>
  <sect2>Description:<p>
	Text=`This is a macro that marks the current process as a
	     candidate for preemption.  It is erroneous to invoke
	     PRE_PreemptMe () if LWP_Init has not been
	     called.
)

<sect1> PRE_BeginCritical -- Enter a critical section <p>
  <sect2>Call:<p>
    <em>  PRE_BeginCritical(</em>  <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      
    </descrip>
  <sect2>Description:<p>
	     This routine places the current LWP in a <em>Critical
	     Section</em>.  Upon return, involunatry preemptions of this
	     process will no longer occur.  Note that this is a macro
	     and that LWP_Init must have been
	     
<sect1> PRE_EndCritical -- Leave a critcal section, <p>
  <sect2>Call:<p>
    <em>  PRE_EndCritical(</em> , <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      
    </descrip>
  <sect2>Description:<p>
	     This routine leaves a critical section previously
	     entered with PRE_BeginCritical ().  If involuntary
	     preemptions were possible before the matching
	     PRE_BeginCritical (), they are once again possible.
	     Note that this is a macro and that
	     LWP_Init must have been
	     previously invoked.
)



<chapt>The Fast Time Package <p>
The Fast Time package allows the caller to find out the current time of day
without incurring the expense of a kernel call.  It works by mapping the
page of the kernel that has the kernels time-of-day variable and
examining it directly.  Currently, this package only works on Suns.  You may
call the routines on other machines, but they will run more slowly.

The initialization routine for this package is fairly expensive since it
does a lookup of a kernel symbol via nlist ().  If you have a program which
runs for only a short time, you may wish to call @FT(Init) with the
<tt>notReally</tt> parameter true to prevent the lookup from taking place.  This
is useful if you are using another package that uses Fast Time (such as
RPC2).


<sect>Fast Time Primitives<p>

<sect1>FT_Init  -- Initialize the Fast Time package <p>
  <sect2>Call:<p>
    <em>int FT_Init(</em><bf>in</bf> int printErrors&gt;, @w&lt;<bf>in</bf> int notReally  <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      <tag/printErrors/Print error messages on stderr if somethingn goes wrong
      <tag/notReally/Dont really do the memory mapping.  Make <bf>FT_GetTimeOfDay</bf>
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      <tag/0/No problems
      <tag/-1/Error in initialization
    </descrip>
  <sect2>Description:<p>
	This call mmaps the kernel page with the time of day variable.
	      If the routine returns -1, calls to <bf>FT_GetTimeOfDay</bf>
	      will still work properly, but will make a kernel call.
)

<sect1>FTGetTimeOfDay  -- Get the time of day from the mapped kernel pages <p>
  <sect2>Call:<p>
    <em>int FTGetTimeOfDay(</em>  <em>)</em>
  </sect2>  <sect2>Parameters:<p>
    <descrip>
      <tag/tv/Where to put the time of day
      <tag/tz/Where to put the time zone information
    </descrip>
  <sect2>Completion Codes:<p>
    <descrip>
      <tag/0/No problem
      <tag/-1/Something went wrong
    </descrip>
  <sect2>Description:<p>
	      This function has the same calling sequence as the kernels
	      <bf>gettimeofday</bf> routine.  If the <bf>tz</bf> parameter is not zero,
	      or if initialization failed, or if the <bf>notReally</bf> parameter
	      in the initialization was true, then this routine calls
	      <bf>gettimeofday</bf>.  Otherwise, it looks in the mapped page of
	      the kernel to get the time of day.&gt;



