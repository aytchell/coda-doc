@Chapter(RPC2 Runtime System)
<label id="RuntimeSystem">

The purpose of this section is to describe the calls provided by the
RPC2 library.
These calls deal with contiguous <em>Packet Buffers</em>
each of which consists of a:
@begin(description)
<em>Prefix</em>@\which is of fixed length, and is used internally by the runtime
system.  It is NOT transmitted.

<em>Header</em>@\which is also of fixed length, and whose format is understood by
the runtime system. The opcode associated with the RPC, sequencing 
information, and the completion code returned by the remote site are the kinds
of information found here.

<em>Body</em>@\of arbitrary size.  It is NOT interpreted by the runtime system,
and is used to transmit the input and output parameters of an RPC.
@end(description)

Appendix <ref id="rpc2.h" name="XXX"> contains the header file <em>rpc2.h</em>, that defines
the packet format as well as numerous other definitions used in the call
descriptions that follow.
Of course, the actual header files are the authoritative source of
these definitions, and will be more up-to-date than this manual.

The following sections define the RPC2 runtime calls.  Some of these
calls are not relevant to you if you use RP2Gen.
Others, such as the initialization and export calls,
are pertinent to all users of RPC2.



<sect1>Client-related Calls<p>


@PasCall(Tag=&lt;NewBinding&gt;,
	CallName=`@RPC2&lt;NewBinding&gt;, Abstract=`Create a new connection,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(HostIdent) *Host&gt;, @w&lt;<bf>in</bf> @RPC2(PortalIdent) *Portal&gt;, @w&lt;<bf>in</bf> @RPC2(SubsysIdent) *Subsys&gt;,  @w&lt;<bf>in</bf> @RPC2(BindParms) *Bparms&gt;, @w&lt;<bf>out</bf> @RPC2(Handle) *ConnHandle&gt;,
	P1=`Host, PD1=`The identity of the remote host on which the server to be contacted is located.  This may be specified as a string name or as an Internet address.  In the former case the RPC runtime system will do the necessary name resolution.,
	P2=`Portal, PD2=`An identification of the server process to be contacted at the remote site. Portals are unique on a given host.  A portal  may be specified as a string name or as an Internet port value.  In the former case the RPC runtime system will do the necessary name to port number conversion.  Support for other kinds of portals (such as Unix domain) may be available in future.,
	P3=`Subsys, PD3=`Which of the potentially many subsystems supported by the remote server is desired.  May be specified as a number or as a name.  In the latter case, the RPC runtime system will do the translation from name to number.,
	P4=`Bparms, PD4=`Type @RPC2(BindParms) is a struct containing 5 fields. The first field SecurityLevel is one of the constants @RPC2(OPENKIMONO), @RPC2(ONLYAUTHENTICATE), @RPC2(HEADERSONLY) or @RPC2(SECURE). The second filed EncryptionType describes what kind of encryption to be used on this connection.  For example, @RPC2(XOR), @RPC2(DES), etc. Ignored if SecurityLevel is @RPC2(OPENKIMONO).  The bind will fail if the remote site does not support the requested type of encryption. The third field SharedSecret is an encryption key known by the callback procedure on the server side to be uniquely associated with ClientIdent. Used by the RPC runtime system in the authentication handshakes.  May be NULL if SecurityLevel is @RPC2(OPENKIMONO). The fourth field ClientIdent provides the information for the server to uniquely identify this client and to obtain SharedKey. Not interpreted by the RPC runtime system. Only the GetKeys callback procedure on the server side need understand the format of ClientIdent.  May be NULL if SecurityLevel is @RPC2(OPENKIMONO). The fifth field SideEffectType describes what kind of side effects are to be associated with this connection.  The only side effects intially supported are bulk-transfers of files, identified by type SMARTFTP. May be 0 if no side effects are ever to be attempted on this connection.,
	P5=`ConnHandle, PD5=`An unique integer returned by the call, identifying this connection. This is not necessarily a small-valued integer.,
	CC1=`@RPC2(SUCCESS), CCD1=`All went well,
	CC2=`@RPC2(NOBINDING), CCD2=`The specified host, server or subsystem could not be contacted,
	CC3=`@RPC2(WRONGVERSION), CCD3=`The client and server runtime systems are  incompatible.  Note that extreme incompatibilty may result in the server being unable to respond even with this error code.  In such a case the server will appear to be down, resulting in a @RPC(NOBINDING) return code.,
	CC4=`@RPC2(OLDVERSION), CCD4=`This is a warning.  The @RPC2(VERSION) values on client and server sides are different.  Normal operation is still possible, but one of you is running an obsolete version of the run time system.  You should obtain the latest copy of the RPC runtime system and recompile your code.,
	CC5=`@RPC2(NOTAUTHENTICATED), CCD5=`A SecurityLevel other than @RPC2(OPENKIMONO) was specified, and the server did not accept your credentials.,
	CC6=`@RPC2(SEFAIL1), CCD6=`The associated side effect routine indicated a minor failure.  The connection is established.and usable.,
	CC7=`@RPC2(SEFAIL2), CCD7=`The associated side effect routine indicated a serious failure.  The connection is not established.,
	CC8=`@RPC2(FAIL), CCD8=`Some other mishap occurred.,
	Text=`Creates a new connection and binds to a remote server on a 
		remote host.  The subsystem information is passed on to that server to alert it to the kind of
		remote procedure calls that it may expect on this connection.
		
	A client/server version check is performed to ensure that
	the runtime systems are compatible.  Note that there are really two version checks.  One is for the RPC network protocol
	and packet formats, and this must succeed.  The other check reports a warning if you have a different RPC runtime system
	from the server.  You may also wish to do a higher-level check, to ensure that the client and
	server application code are compatible.
	
	The SecurityLevel parameter determines the degree to which you can
	trust this connection.  If @RPC2(OPENKIMONO) is specified, the 
	connection is not authenticated and no encryption is done on future
	requests and responses.  If @RPC2(ONLYAUTHENTICATE) is specified, an
	authentication handshake is done to ensure that the client and the 
	server are who they claim to  to be (the fact that the server can 
	find SharedSecret from ClientIdent is assumed to be proof of its
	identity).  If @RPC2(SECURE) is specified, the connection is 
	authenticated and all future transmissions on it are encrypted using
	a session key generated during the authentication handshake.  @RPC2(HEADERSONLY) is similar
	to @RPC2(SECURE), except that only RPC headers are encrypted.

	The kind of encryption used is specified in EncryptionType.  The remote site must specify
	an @RPC2(GetRequest) with an EncryptionTypeMask that includes this encryption type.
	)
@PasCall(Tag=&lt;Bind&gt;,
	CallName=`@RPC2&lt;Bind&gt;, Abstract=`Obsolete: use @RPC2(NewBinding),
	ParmList =`@w&lt;<bf>in</bf> long SecurityLevel&gt;,  @w&lt;<bf>in</bf> long EncryptionType&gt;, @w&lt;<bf>in</bf> @RPC2(HostIdent) *Host&gt;, @w&lt;<bf>in</bf> @RPC2(PortalIdent) *Portal&gt;, @w&lt;<bf>in</bf> @RPC2(SubsysIdent) *Subsys&gt;,  @w&lt;<bf>in</bf> long SideEffectType&gt;, @w&lt;<bf>in</bf> @RPC2(CountedBS) *ClientIdent&gt;, @w&lt;<bf>in</bf> @RPC2(EncryptionKey) *SharedSecret&gt;, @w&lt;<bf>out</bf> @RPC2(Handle) *ConnHandle&gt;,
	P1=`, PD1=`<em></em>,
	Text=`
	)

		

@PasCall(Tag=&lt;MakeRPC&gt;,
	CallName=`@RPC2(MakeRPC), Abstract=`Make a remote procedure call (with possible side-effect),
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) ConnHandle&gt;, @w&lt;<bf>in</bf>  @RPC2(PacketBuffer) *Request&gt;, @w&lt;<bf>in</bf> @SE(Descriptor) *SDesc&gt;, @w&lt;<bf>out</bf>  @RPC2(PacketBuffer) **Reply&gt;, @w&lt;<bf>in</bf> struct timeval *Patience&gt;, @w&lt;<bf>in</bf> long EnqueueRequest&gt;,
	P1=`ConnHandle, PD1=`identifies the connection on which the call is to be made,
	P2=`Request, PD2=`A properly formatted request buffer.,
	P3=`SDesc, PD3=`A side effect descriptor with local fields filled in.  May be NULL if no side effects will occur as a result of this call.,
	P4=`Reply, PD4=`On return, it will point to a response buffer
			holding the response from the server.  You should free this buffer when you are done with it.,
	P5=`Patience, PD5=`Maximum time to wait for remote site to 
			respond.  A NULL pointer indicates infinite patience.,
	P6=`EnqueueRequest, PD6=`Specifies whether the caller should be blocked if ConnHandle is already servicing an RPC request from some other lwp.  If this variable is 1 the caller is blocked.  Otherwise a return code of @RPC2(CONNBUSY) is returned.,
	CC1=`@RPC2(SUCCESS), CCD1=`All went well. ,
	CC2=`@RPC2(NOCONNECTION), CCD2=`ConnHandle does not refer to a valid connection.,
	CC3=`@RPC2(TIMEOUT), CCD3=`A response was not received soon enough. Occurs only if the Patience parameter was non-NULL.,
	CC4=`@RPC2(SEFAIL1), CCD4=`The associated side effect resulted in a minor failure.  Future calls on this connection will still work.,
	CC5=`@RPC2(SEFAIL2), CCD5=`The associated side effect resulted in a serious failure.  Future calls on this connection will fail.,
	CC6=`@RPC2(DEAD), CCD6=`The remote site has been deemed dead or unreachable.  Note that this is orthogonal to an @RPC2(TIMEOUT) return code.,
	CC7=`@RPC2(NAKED), CCD7=`The remote site sent an explicit negative acknowledgement.  This can happen if that site thought you were dead, or if someone at that site unbound your connection.,
	CC8=`@RPC2(CONNBUSY), CCD8=`EnqueueRequest specified 0 and ConnHandle is currently servicing a call. Try again later. ,
	CC9=`@RPC2(FAIL), CCD9=`Other assorted calamities, such as attempting to use a connection already declared broken.,
	Text=`The workhorse routine, used to make remote calls after establishing a connection.
		The call is sequential and the calling lwp is blocked until the call completes.
		The associated side effect, if any, is finished before the call completes.
		The listed completion codes are from the local RPC stub.
		Check the @RPC2(ReturnCode) fields of the reply  and the status fields of SDesc to see what the remote
		site thought of your request.  Without an explicit timeout interval the remote site can take as long as it
		wishes to perform the requested operation and associated side effects.  The RPC protocol checks periodically
		to ensure that the remote site is alive.  If an explicit  Patience timeout interval is specified,  
		the call must complete within that time.
	)



@PasCall(Tag=&lt;MultiRPC&gt;,
	CallName=`@RPC2(MultiRPC), Abstract=`Make a collection of remote procedure calls,
	ParmList=`@w&lt;<bf>in</bf> int HowMany&gt;, @w&lt;<bf>in</bf> @RPC2(Handle) ConnHandleList&lsqb; &rsqb;&gt;, @w&lt;<bf>out</bf> @RPC2(Integer) *RCList&gt;, @w&lt;<bf>in out</bf> @RPC2(Multicast) *MCast&gt;, @w&lt;<bf>in</bf> @RPC2(PacketBuffer) *Request&gt;, @w&lt;<bf>in</bf> @SE(Descriptor) SDescList&lsqb; &rsqb;&gt;, @w&lt;<bf>in</bf> long (*UnpackMulti) ()&gt;, @w&lt;<bf>in out</bf> @ARG(INFO) *ArgInfo&gt;, @w&lt;<bf>in</bf> struct timeval *Patience&gt;,
	P1=`HowMany, PD1=`How many servers to contact,
	P2=`ConnHandleList, PD2=`Array of length HowMany, containing the handles of the connections on which calls are to be made.,
	P3=`Request, PD3=`A properly formatted request buffer.,
	P4=`RCList, PD4=`Array of length HowMany, into which RPC2 will place return codes for each of the connections specified in ConnHanleList.  May be specified as NULL if return codes will not be examined.,
	P5=`MCast, PD5=`Pointer to multicast sturcture.  Set to NULL for now.,
	P6=`SDescList, PD6=`Array of length HowMany, containing side effect descriptors for each of the connections specified in ConnHandleList.,
	P7=`UnpackMulti, PD7=`Pointer to unpacking routine called by RPC2
when each server response as received. If RP2Gen is used, this will be
supplied by @MRPC(MakeMulti). Otherwise, it must be supplied by the client.,
	P8=`ArgInfo, PD8=`A pointer to a structure containing argument information. This
structure is not examined by RPC2; it is passed untouched to 
 UnpackMulti. If RP2Gen is used, this structure will be supplied by
@MRPC(MakeMulti). Otherwise, it can be used to pass any structure desired by the
client or supplied as NULL.,
	P9=`Patience, PD8=`Maximum time to wait for remote sites to respond. A NULL pointer indicates infinite patience as long as RPC2 believes that the server is alive. Note that this timeout value is orthogonal to the RPC2 internal timeout for determining connection death.,
	CC1=`@RPC2(SUCCESS), CCD1=`All servers returned successfully, or all servers until client-initiated abort returned successfully. Individual server response information is supplied via UnpackMulti to the user handler routine supplied in the ArgInfo structure.,
	CC2=`@RPC2(TIMEOUT), CCD2=`The user specified timeout expired before all the servers responded.,
	CC3=`@RPC2(FAIL), CCD3=`Something other than SUCCESS or TIMEOUT occurred. More detailed information is supplied via UnpackMulti to the user handler routine supplied in the ArgInfo structure.,
	Text=`Logically identical to iterating through ConnHandleList and making @RPC2(MakeRPC) calls to each specified
	connection using Request as the request block, but this call will be considerably faster than explicit
	iteration. The calling lightweight process
	blocks until either the client requests that the call abort or one of the following is true about each of
	the connections specified in ConnHandleList: a reply has been received, a hard error has been detected for
	that connection, or the specified timeout has elapsed.

	The ArgInfo structure exists to supply argument packing and
unpacking information in the case where RP2Gen is used. Since its value is
not examined by RPC2, it can contain any pointer that a non-RP2Gen generated
client wishes to supply.

	Similarly, UnpackMulti will point to a specific unpacking routine in
the RP2Gen case. If the RP2Gen interface is not used, you should assume that the return
codes of the supplied routine must conform to the specifications in section
 <ref id="UnpackMultiInfo" name="XXX">.

Side effects are supported as in the standard RPC2 case except that the
client must supply a separate <bf>@SE&lsqb;Descriptor&rsqb;</bf> for each connection. The
format for the <bf>@SE&lsqb;Descriptor&rsqb;</bf> argument is described in Section
 <ref id="interface" name="XXX">.
It will often be useful to supply
connection specific information such as unique file names in the
 <bf>@SE&lsqb;Descriptor&rsqb;</bf>.
)

<sect1>Server-related RPC Calls<p>
@PasCall(Tag=&lt;Export&gt;,
	CallName=`@RPC2(Export), Abstract=`Indicate willingness to accept calls for a subsystem,
	ParmList=`@w&lt;<bf>in</bf> @RPC2(SubsysIdent) *Subsys&gt;,
	P1=`Subsys, PD1=`Specifies a subsystem that will be henceforth recognized by this server.  This is either an integer or a symbolic name that can be translated to the unique integer identifying this subsystem.,
	CC1=`@RPC2(SUCCESS), CCD1=`All went well,
	CC2=`@RPC2(DUPLICATESERVER), CCD2=`Your have already exported Subsys.,
	CC3=`@RPC2(BADSERVER), CCD3=`Subsys is invalid.,
	CC4=`@RPC2(FAIL), CCD4=`Something else went wrong.,
	Text=` Sets up	internal tables so that when a remote client performs an @RPC2(Bind)() operation 
		specifying this host-portal-subsystem triple, the RPC runtime system will accept it.
		A server may declare itself to be serving more than one subsystem by making more than one
		 @RPC2(Export) calls.
	
	)

@PasCall(Tag=&lt;DeExport&gt;,
	CallName=`@RPC2(DeExport), Abstract=`Stop accepting new connections for one or all subsystems.,
	ParmList=`@w&lt;<bf>in</bf> @RPC2(SubsysIdent) *Subsys&gt;,
	P1=`Subsys, PD1=`Specifies the subsystem  to be deexported. This is either an integer or a symbolic name that can be translated to the unique integer identifying this subsystem. A value of NULL deexports all subsystems.,
	CC1=`@RPC2(SUCCESS), CCD1=`All went well,
	CC2=`@RPC2(BADSERVER), CCD2=`Subsys is not a valid subsystem, or has not been previously exported.,
	CC4=`@RPC2(FAIL), CCD4=`Something else went wrong.,
	Text=`After this call, no new connections for subsystem Subsys will be accepted.  The subsystem may, however, be exported
		again at a later time.  Note that existing connections are not broken by this call.
	)

 
@PasCall(Tag=&lt;GetRequest&gt;,
	CallName=`@RPC2(GetRequest), Abstract=`Wait for an RPC request or a new connection,
	ParmList=`@w&lt;<bf>in</bf> @RPC2(RequestFilter) *Filter&gt;, @w&lt;<bf>out</bf> @RPC2(Handle) *ConnHandle&gt;, @w&lt;<bf>out</bf>  @RPC2(PacketBuffer) **Request&gt;, @w&lt;<bf>in</bf> struct timeval *Patience&gt;, @w&lt;<bf>in</bf> long (*GetKeys) ()&gt;, @w&lt;<bf>in</bf> long EncryptionTypeMask&gt;, @w&lt;<bf>in</bf> long (*AuthFail) ()&gt;,
	P1=`Filter, PD1=`A filter specifying which requests are acceptable.  See description below.,
	P2=`ConnHandle, PD2=`Specifies the connection on which the request was received.,
	P3=`Request, PD3=`Value ignored on entry. On return, it will point to a buffer
			holding the  response from the client.  Free this buffer after you are done with it.,
	P4=`Patience, PD4=`A timeout interval specifying how long to wait for a request. 
		 If NULL, infinite patience is assumed.,
	P5=`GetKeys, PD5=`Pointer to a callback procedure to obtain authentication and session keys. See description below.
May be NULL if no secure bindings to this server are to be accepted.,
	P6=`EncryptionTypeMask, PD6=`A bit mask specifying which types of encryption is supported. Binds from clients who request an encryption type not specified in this mask will fail.,
	P7=`AuthFail, PD7=`Pointer to a callback procedure to be called when an authentication failure occurs. See description below.  May be NULL if server does not care to note such failures.,
	CC1=`@RPC2(SUCCESS), CCD1=`I have a request for you in Request.  New connections result in a fake request.,
	CC2=`@RPC2(TIMEOUT), CCD2=`Specified time interval expired.,
	CC3=`@RPC2(BADFILTER), CCD3=`A nonexistent connection or subsystem was specified in Filter.,
	CC4=`@RPC2(SEFAIL1), CCD4=`The associated side effect routine indicated a minor failure.  Future calls on this connection will still work.,
	CC5=`@RPC2(SEFAIL2), CCD5=`The associated side effect routine indicated a serious failure.  Future calls on this connection will fail too.,
	CC6=`@RPC2(DEAD), CCD6=`You were waiting for requests on a specific connection and that site has been deemed dead or unreachable.,
	CC7=`@RPC2(FAIL), CCD7=`Something irrecoverable happened.,
	Text=` The call blocks the calling lightweight process until a request is available, a new connection is made,
or until the specified timeout period has elapsed.  The Filter parameter allows a great deal of flexibility in selecting
precisely which calls are acceptable.  New connections result in a fake request with a body of type @RPC2(NewConnection). Do not try
to do a @RPC2(SendResponse) to this call.  All other @RPC2(GetRequest) calls should be eventually matched with a corresponding
@RPC2(SendResponse) call.

The fields of @RPC2(NewConnection) are self-explanatory.  Note that you must invoke @RPC2(Enable)() after you have
handled the new connection packet for further requests to be visible.  If you are using RP2Gen, this is done
for you automatically by the generated code that deals with new connections. 

The callback procedure for key lookup should be defined as follows
@begin(Format, LeftMargin +2cm, Indent -1cm, break around, FaceCode i)
long GetKeys (@w&lt;<bf>in</bf> @RPC2(CoundedBS) *ClientIdent&gt;,
	@w&lt;<bf>out</bf> @RPC2(EncryptionKey) *IdentKey&gt;,
	@w&lt;<bf>out</bf> @RPC2(EncryptionKey) *SessionKey&gt;)
@end(Format)

GetKeys () will be called at some point in the 
authentication handshake.  It should return 0 if 
ClientIdent is successfully looked up, and -1 if the
handshake is to be terminated.  It should fill IdentKey
with the key to be used in the handshake, and SessionKey
with an arbitrary key to be used for the duration of this
connection.  You may, of course, make SessionKey the same as IdentKey.

The callback procedure for noting authentication failure should be defined as follows:
@begin(Format, LeftMargin +2cm, Indent -1cm, break around, Facecode i)
long AuthFail (@w&lt;<bf>in</bf> @RPC2(CoundedBS) *ClientIdent&gt;,
	@w&lt;<bf>in</bf> @RPC2(Integer) EncryType&gt;,
	@w&lt;<bf>in</bf> @RPC2(HostIdent) *PeerHost&gt;,
	@w&lt;<bf>in</bf> @RPC2(PortalIdent) *PeerPortal&gt;)
@end(Format)

AuthFail () will be called after an @RPC2(NOTAUTHENTICATED) packet 
has been sent to the client. The parameters give information about
the client who was trying to authenticate himself, the type of encryption
requested, and the site from which the @RPC2(Bind)() was attempted.
The callback procedure will typically record this in a log file somewhere.
	)


@PasCall(Tag=&lt;Enable&gt;,
	CallName=`@RPC2(Enable), Abstract=`Allow servicing of requests on a new connection,
	ParmList=`@w&lt;<bf>in</bf> @RPC2(Handle) ConnHandle&gt;,
	P1=`ConnHandle, PD1=`Which connection is to be enabled,
	CC1=`@RPC2(SUCCESS), CCD1=`Enabled the connection.,
	CC2=`@RPC2(NOCONNECTION), CCD2=`A bogus connection was specified.,
	Text=`Typically invoked  by the user at the end of his NewConnection routine, after setting up his
		higher-level data structures appropriately.  Until a connection is enabled, RPC2 guarantees
		that no requests on that connection will be returned in a @RPC2(GetRequest) call.
		Such a request from a client will, however, be held and responded to with @RPC2(BUSY) signals
		until the connection is enabled.  This call is present primarily to avoid race hazards in
		higher-level connection establishment.  Note that RP2Gen automatically generates this call at 
		after a NewConnection routine.

	)


@PasCall(Tag=&lt;SendResponse&gt;,
	CallName=`@RPC2(SendResponse), Abstract=`Respond to a request from my client,
	ParmList=`@w&lt;<bf>in</bf> @RPC2(Handle) ConnHandle&gt;, @w&lt;<bf>in</bf>  @RPC2(PacketBuffer) *Reply&gt;,
	P1=`ConnHandle, PD1=`Which connection the response is to be sent on.,
	P2=`Reply, PD2=`A filled-in buffer containing the reply to be sent to the client.,
	CC1=`@RPC2(SUCCESS), CCD1=`I sent your response.,
	CC2=`@RPC2(NOTWORKER), CCD2=`You were not given a request to service.,
	CC3=`@RPC2(SEFAIL1), CCD3=`The associated side effect routine indicated a minor failure.  Future calls on this connection will still work.,
	CC4=`@RPC2(SEFAIL2), CCD4=`The associated side effect routine indicated a serious failure.  Future calls on this connection will fail too.,
	CC5=`@RPC2(FAIL), CCD5=`Some irrecoverable failure happened.,
	Text=`Sends the specified reply to the caller.  Any outstanding side effects are completed before Reply is sent.
	Encryption, if any, is done in place and will clobber the Reply buffer.  Note that this call returns immediately after sending the reply; it does not wait for an acknowledgement from the client.

	)


@PasCall(Tag=&lt;InitSideEffect&gt;,
	CallName=`@RPC2(InitSideEffect), Abstract=`Initiate side effect,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) ConnHandle&gt;, @w&lt;<bf>in</bf> @SE(Descriptor) *SDesc&gt;,
	P1=`ConnHandle, PD1=`The connection on which the side effect is to be initiated.,
	P2=`SDesc, PD2=`A filled-in side effect descriptor.,
	CC1=`@RPC2(SUCCESS), CCD1=`The side effect has been initiated.,
	CC2=`@RPC2(NOTSERVER), CCD2=`Only one side effect is allowed per RPC call. This has to be initiated between the GetRequest and SendResponse of that call.  You are violating one of these restrictions.,
	CC3=`@RPC2(SEFAIL1), CCD3=`The associated side effect routine indicated a nonfatal failure.  Future calls on this connection will work.,
	CC4=`@RPC2(SEFAIL2), CCD4=`The associated side effect routine indicated a serious failure.  Future calls on this connection will fail too.,
	CC5=`@RPC2(FAIL), CCD5=`Other assorted calamities,
	Text=`Initiates the side effect specified by SDesc on ConnHandle.  The call does not wait for the completion of the side effect.
	    If you need to know what happened to the side effect, do a @RPC2(CheckSideEffect) call with appropriate flags.
	)


@PasCall(Tag=&lt;CheckSideEffect&gt;,
	CallName=`@RPC2(CheckSideEffect), Abstract=`Check progress of side effect,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) ConnHandle&gt;, @w&lt;<bf>inout</bf> @SE(Descriptor) *SDesc&gt;, @w&lt;<bf>in</bf> long Flags&gt;,
	P1=`ConnHandle, PD1=`The connection on which the side effect has been initiated.,
	P2=`SDesc, PD2=`The side effect descriptor as it was returned by the previous @RPC2(InitSideEffect)
		or @RPC2(CheckSideEffect) call on ConnHandle.  On output, the status fields are filled in.,
	P3=`Flags, PD3=`Specifies what status is desired.  This call will block until the requested status is available.
		This is a bit mask, with @RPC2(GETLOCALSTATUS) and @RPC2(GETREMOTESTATUS) bits indicating local and remote status.
		A Flags value of 0 specifies a polling status check: no blocking will occur and the currently known local
		and remote status will be returned.,
	CC1=`@RPC2(SUCCESS), CCD1=`The requested status fields have been made available.,
	CC2=`@RPC2(NOTSERVER), CCD2=`No side effect is ongoing on ConnHandle.,
	CC3=`@RPC2(SEFAIL1), CCD3=`The associated side effect routine indicated a nonfatal failure.  Future calls on this connection will work.,
	CC4=`@RPC2(SEFAIL2), CCD4=`The associated side effect routine indicated a serious failure.  Future calls on this connection will fail too.,
	CC5=`@RPC2(FAIL), CCD5=`Other assorted calamities,
	Text=`Checks the status of a previously initiated side effect.
			This is a (potentially) blocking call, depending on the specified flags.
	)



<sect1>Miscellaneous Calls<p>
@PasCall(Tag=&lt;Init&gt;,
	CallName=`@RPC2&lt;Init&gt;, Abstract=`Perform runtime system initialization,
	ParmList = `@w&lt;<bf>in</bf> char *VersionId&gt;, @w&lt;<bf>in</bf> long Options&gt;, @w&lt;<bf>in</bf> @RPC2(PortalIdent) *PortalList&lsqb;&rsqb;&gt;, @w&lt;<bf>in</bf> long HowManyPortals&gt;,  @w&lt;<bf>in</bf> long RetryCount&gt;, @w&lt;<bf>in</bf> struct timeval *KeepAliveInterval&gt;,
	P1=`VersionId, PD1=`Set this to the constant @RPC2(VERSION).  The current value of this string  constant must be identical to the value at the time the client runtime system was compiled.,
	P2=`Options, PD2=`Right now there are no options.,
	P3=`PortalList, PD3=`An array of unique network addresses within this machine, on which requests can be listened for, and to which responses to
	outgoing calls can be made.  In the Internet domain this translates into a port number or a symbolic name
	that can be mapped to a port number.   You need to specify this parameter even if you are only going to be a
	client and not export any subsystems.  A value of NULL will cause RPC2 to select an arbitrary, nonassigned portal.,
	P4=`HowManyPortals, PD4=`Specifies the number of elements in the array PortalList.,
	P5=`RetryCount, PD5=`How many times to retransmit a packet before giving up all hope of receiving acknowledgement of its receipt.  Should be in the range 1 to 30. Use a value of -1 to obtain the  default.,
	P6=`KeepAliveInterval, PD6=`How often to probe a peer during a long RPC call.  This value is also used to calculate the retransmission intervals when packet loss is suspected by the RPC runtime system.  Use NULL to obtain the default.,
	CC1=`@RPC2(SUCCESS), CCD1=`All went well, 
	CC2=`@RPC2(FAIL), CCD2=`Unable to initialize client. Check for bogus parameter values.,
	CC3=`@RPC2(WRONGVERSION), CCD3=`The header file and the library have different versions.  This should never happen in a properly administered system.,
	CC4=`@RPC2(LWPNOTINIT), CCD4=`The LWP package has not been properly initialized.  Be sure to call @LWP(Init)() before calling @RPC2(Init)().,
	CC5=`@RPC2(BADSERVER), CCD5=`The PortalList field specifies an invalid address.,
	CC6=`@RPC2(DUPLICATESERVER), CCD6=`An entry in PortalList specifies an address which is already in use on this machine,
	CC7=`@RPC2(SEFAIL1), CCD7=`The associated side effect routine indicated a minor failure.,
	CC8=`@RPC2(SEFAIL2), CCD8=`The associated side effect routine indicated a serious failure.,
	Text=`Initializes the RPC runtime system in this process.  This call should be made before any other call in this 
		package is made.  It should be preceded by an initialization call to the LWP package and a call to 
		@SE(SetDefaults) with InitialValues as argument.
		If you get a wrong version indication, obtain a consistent version of the header files and the RPC 
		runtime library and recompile your code. Note that this call incorporates a call to initialize IOMGR.

		RetryCount and KeepAliveInterval together define what it means for a remote site to be dead or
		unreachable.  Packets are retransmitted at most RetryCount times until positive acknowledgement of their
		receipt is received.  This is usually piggy-packed with useful communication, such as the reply to a 
		request.  The KeepAliveInterval is used for two purposes: to determine how often to check a remote site
		during a long RPC call, and to calculate the intervals between the RetryCount retransmissions of a packet.
		The RPC runtime system guarantees detection of remote site failure or network partition within a time
		period in the range  KeepAliveInterval to twice KeepAliveInterval.  See Chapter <ref id="RetryChapter" name="XXX"> for further information on the retry algorithm.

		Remember to activate each side effect, XXX, that you are interested in by invoking the
		corresponding @XXX()Activate () call, prior to calling @RPC2(Init).

		You may get a warning about SO@ux&lsqb; &rsqb;GREEDY being undefined, if your kernel does not have an ITC bug fix.  RPC2 will still work but may be slower and more likely to drop connections during bulk transfer.  This is because of insufficient default packet buffer space  within the Unix kernel.
	)


@PasCall(Tag=&lt;Unbind&gt;,
	CallName=`@RPC2(Unbind), Abstract=`Terminate a connection by client or server,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) ConnHandle&gt;,
	P1=`ConnHandle, PD1=`identifies the connection to be terminated,
	CC1=`@RPC2(SUCCESS), CCD1=`All went well,
	CC2=`@RPC2(NOCONNECTION), CCD2=`ConnHandle is bogus,
	CC3=`@RPC2(SEFAIL1), CCD3=`The associated side effect routine indicated a minor failure.,
	CC4=`@RPC2(SEFAIL2), CCD4=`The associated side effect routine indicated a serious failure.,
	CC5=`@RPC2(FAIL), CCD5=`Other assorted calamities,
	Text=`Removes the binding associated with the specified connection.  Normally
		a higher-level  disconnection should be done by an RPC just prior to
		this call.  Note that this call may be used both by a server and a client, and that
		no client/server communication occurs: the unbinding is unilateral.
	)

@PasCall(Tag=&lt;AllocBuffer&gt;,
	CallName=`@RPC2(AllocBuffer), Abstract=`Allocate a packet buffer,
	ParmList =`@w&lt;<bf>in</bf> long MinBodySize&gt;, @w&lt;<bf>out</bf> @RPC2(PacketBuffer) **Buff&gt;,
	P1=`MinBodySize, PD1=`Minimum acceptable body size for the packet buffer.,
	P2=`Buff, PD2=`Pointer to the allocated buffer.,
	CC1=`@RPC2(SUCCESS), CCD1=`Buffer has been allocated and *Buff points to it.,
	CC2=`@RPC2(FAIL), CCD2=`Could not allocate a buffer of requested size.,
	Text=`Allocates a packet buffer of at least the requested size.  The BodyLength field in the header of the
		 allocated packet is set to MinBodySize.  The RPC runtime system maintains its own free list of buffers.
		 Use this call in preference to malloc ().
	)

@PasCall(Tag=&lt;FreeBuffer&gt;,
	CallName=`@RPC2(FreeBuffer), Abstract=`Free a packet buffer,
	ParmList =`@w&lt;<bf>inout</bf> @RPC2(PacketBuffer) **Buff&gt;,
	P1=`Buff, PD1=`Pointer to the buffer to be freed. Set to NULL by the call.,
	CC1=`@RPC2(SUCCESS), CCD1=`Buffer has been freed. *Buff has been set to NULL.,
	CC2=`@RPC2(FAIL), CCD2=`Could not free buffer.,
	Text=`Returns a packet buffer to the internal free list.  Buff is set to NULL specifically
		to simplify locating bugs in buffer usage.
	)


@PasCall(Tag=&lt;GetPrivate&gt;,
	CallName=`@RPC2(GetPrivatePointer), Abstract=`Obtain private data mapping for a connection.,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) WhichConn&gt;, @w&lt;<bf>out</bf> char **PrivatePtr&gt;,
	P1=`WhichConn, PD1=`Connection whose private data pointer is desired.,
	P2=`PrivatePtr, PD2=`Set to point to private data.,
	CC1=`@RPC2(SUCCESS), CCD1=`*PrivatePtr now points to the private data associated with this connection.,
	CC2=`@RPC2(FAIL), CCD2=`Bogus connection specified.,
	Text=`Returns a pointer to the private data associated with a connection.  No attempt is made to validate
		this pointer.
	)

@PasCall(Tag=&lt;SetPrivate&gt;,
	CallName=`@RPC2(SetPrivatePointer), Abstract=`Set private data mapping for a connection.,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) WhichConn&gt;, @w&lt;<bf>in</bf> char *PrivatePtr&gt;,
	P1=`WhichConn, PD1=`Connection whose private data pointer is to be set.,
	P2=`PrivatePtr, PD2=`Pointer to private data.,
	CC1=`@RPC2(SUCCESS), CCD1=`Private pointer set for this connection.,
	CC2=`@RPC2(FAIL), CCD2=`Bogus connection specified.,
	Text=`Sets the private data pointer associated with a connection.  No attempt is made to validate
		this pointer.
	)

@PasCall(Tag=&lt;GetSideEffect&gt;,
	CallName=`@RPC2(GetSEPointer), Abstract=`Obtain per-connection side-effect information..,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) WhichConn&gt;, @w&lt;<bf>out</bf> char **SEPtr&gt;,
	P1=`WhichConn, PD1=`Connection whose side-effect data pointer is desired.,
	P2=`SEPtr, PD2=`Set to point to side-effect data.,
	CC1=`@RPC2(SUCCESS), CCD1=`*SEPtr now points to the side effect data associated with this connection.,
	CC2=`@RPC2(FAIL), CCD2=`Bogus connection specified.,
	Text=`Returns a pointer to the side effect data associated with a connection.  No attempt is made to validate
		this pointer.  This call is should only by the side effect routines, not by clients.
	)

@PasCall(Tag=&lt;SetSideEffect&gt;,
	CallName=`@RPC2(SetSEPointer), Abstract=`Set per-connection side-effect connection.,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) WhichConn&gt;, @w&lt;<bf>in</bf> char *SEPtr&gt;,
	P1=`WhichConn, PD1=`Connection whose side effect pointer is to be set.,
	P2=`SEPtr, PD2=`Pointer to side effect data.,
	CC1=`@RPC2(SUCCESS), CCD1=`Side effect pointer set for this connection.,
	CC2=`@RPC2(FAIL), CCD2=`Bogus connection specified.,
	Text=`Sets the side effect data pointer associated with a connection.  No attempt is made to validate
		this pointer.  This call should only be used by the side effect routines, not by clients.
	)

@PasCall(Tag=&lt;GetPeerInfo&gt;,
	CallName=`@RPC2(GetPeerInfo), Abstract=`Obtain miscellaneous connection information.,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) WhichConn&gt;, @w&lt;<bf>out</bf> @RPC2(PeerInfo) *PeerInfo&gt;,
	P1=`WhichConn, PD1=`Connection whose peer you wish to know about,
	P2=`PeerInfo, PD2=`Data structure to be filled.,
	CC1=`@RPC2(SUCCESS), CCD1=`Peer information has been obtained for this connection.,
	CC2=`@RPC2(FAIL), CCD2=`Bogus connection specified.,
	Text=`Returns the peer information for a connection.  Also returns other miscellaneous
	    connection-related information, such as the securrity level in use.
	    This information may be used by side-effect routines or high-level
	    server code to perform RPC bindings in the opposite direction.
	    The RemoteHandle and Uniquefier  information are  useful
	    as end-to-end identification between client code and server code.
	)

@PasCall(Tag=&lt;LamportTime&gt;,
	CallName=`@RPC2(LamportTime), Abstract=`Get Lamport time,
	ParmList =`,
	Text=`Returns the current Lamport time.  Bears no resemblance to the actual time of day. Each call
	is guaranteed to return a value at least one larger than the preceding call.  Every RPC packet sent
	and received by this Unix process has a Lamport time field in its header.  The value returned by this
	call is guaranteed to be  greater than any  Lamport time field received or sent before now.  Useful
	for generating unique timestamps in a distributed system.
	)

@PasCall(Tag=&lt;DumpState&gt;,
	CallName=`@RPC2(DumpState), Abstract=`Dump internal RPC state.,
	ParmList =`@w&lt;<bf>in</bf> FILE *OutFile&gt;, @w&lt;<bf>in</bf> long Verbosity&gt;,
	P1=`OutFile, PD1=`File on which the trace is to be produced.  A value of NULL implies stdout.,
	P2=`Verbosity, PD2=`Controls the amount of information dumped.  Right now two values 0 and 1 are meaningfull.,
	CC1=`@RPC2(SUCCESS), CCD1=`The dump has been produced.,
	Text=`You should typically call this routine after calling @RPC(DumpTrace).
	)

@PasCall(Tag=&lt;InitTraceBuffer&gt;,
	CallName=`@RPC2(InitTraceBuffer), Abstract=`Set trace buffer size.,
	ParmList =`@w&lt;<bf>in</bf> long HowMany&gt;,
	P1=`HowMany, PD1=`How many entries the trace buffer should have.  Set it to zero to delete trace buffer.,
	CC1=`@RPC2(SUCCESS), CCD1=`The trace buffer has been adjusted appropriately.,
	Text=`Allows you to create and change the trace buffer at runtime.  All existing trace entries are lost.
	)

@PasCall(Tag=&lt;DumpTrace&gt;,
	CallName=`@RPC2(DumpTrace), Abstract=`Print a trace of recent RPC calls and packets received.,
	ParmList =`@w&lt;<bf>in</bf> FILE *OutFile&gt;, @w&lt;<bf>in</bf> long HowMany&gt;,
	P1=`OutFile, PD1=`File on which the trace is to be produced.  A value of NULL implies stdout.,
	P2=`HowMany, PD2=`The HowMany most recent trace entries are printed.  A value of NULL implies as many trace entries
			as possible.  Values larger than TraceBufferLength specifed in @RPC2(Init) are meaningless.,
	CC1=`@RPC2(SUCCESS), CCD1=`The requested trace has been produced.,
	CC2=`@RPC2(FAIL), CCD2=`The trace buffer had no entries.,
	Text=`Note that it is not necessary for @RPC2(Trace) to be currently set.  You can collect a trace and defer calling
		@RPC2(DumpTrace) until a convenient time.  This call does not alter the current value of @RPC2(Trace).
	)


@PasCall(Tag=&lt;SetDefaults&gt;,
	CallName=`@XXX()SetDefaults, Abstract=`Set an SE initializer to its default values,
	ParmList =`@w&lt;<bf>out</bf> @XXX()Initializer *Initializer&gt;,
	P1=`Initializer, PD1=`Initializer for side effect XXX which you wish to set to default values.,
	CC1=`@RPC2(SUCCESS), CCD1=`,	
	Text=`  Each side effect type, XXX,  defines an initialization structure type, @XXX()Initializer,
		and an initialization routine, @XXX()SetDefaults ().

		A typical initialization sequence consists of the following: for each side effect, XXX, that you
		care about,
		@begin(format)
	 (1) declare a local variable of type @XXX()Initializer,
	 (2) call @XXX()SetDefaults () with this local variable as argument,
	 (3) selectively modify those initial values you care about in the local variable, and
	 (4) call @XXX()Activate () with this local variable as argument.
		@end(format)
		
		Finally call @RPC2(Init).

		This allows you to selectively set parameters of XXX without having to know the  proper values
		for all of the possible parameters.  
		Alas, if only C allowed initialization in type declarations  this routine would be unnecessary.
	)


@PasCall(Tag=&lt;Activate&gt;,
	CallName=`@XXX()Activate, Abstract=`Activates a side effect type and initializes it,
	ParmList =`@w&lt;<bf>in</bf> @XXX()Initializer *Initializer&gt;,
	P1=`Initializer, PD1=`Initializer for side effect XXX.,
	CC1=`@RPC2(SUCCESS), CCD1=`,	
	Text=`Activates side effect XXX.  Code corresponding to this side effect will not be linked in
	    otherwise. See comment for @XXX()SetDefaults () for further details.
	)

@PasCall(Tag=&lt;ErrorMsg&gt;,
        Type = `char *,
	CallName=`@RPC2()ErrorMsg, Abstract=`Describe RPC2 error code,
	ParmList =`@w&lt;<bf>in</bf> long ReturnCode&gt;,
	P1=`ReturnCode, PD1=`Error code returned by any RPC2 call.,
	CC1=`, CCD1=`,	
	Text=`Converts ReturnCode into a string that can be used for printing error messages.  Note that this is the only RPC2 call that returns a non-integer value.
	)


@PasCall(Tag=&lt;SetColor&gt;,
	CallName=`@RPC2(SetColor), Abstract=`Set the color of a connection,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) *Conn, <bf>in</bf> @RPC2(Integer) NewColor&gt;,
	P1=`Conn, PD1=`Connection whose color is to be changed,
	P2=`NewColor, PD2=`The lowest-order byte of this value is used as the new color for this connection.,
	CC1=`@RPC2(SUCCESS), CCD1=`The connection has been colored as requested.,
	CC2=`@RPC2(NOCONNECTION), CCD2=`Connection specified is bogus.,
	Text=`A color is an integer between 0 and 255 that is associated with a connection.  When a packet is sent out on a connection, it acquires this color.  Colors have no implicit significance to RPC2.  But they can be used by other packages such as the Coda failure emulator package@cite&lsqb;CodaManual&rsqb; to selectively induce failures.  For example, in debugging an implementation of a two-phase commit protocol, one needs to test the situation where a failure occurs between the two phases. This situation can be detected by the failure emulator by using packets of different colors for the different phases.  A change in color of a connection takes effect with the next packet that is sent out.
	)


@PasCall(Tag=&lt;GetColor&gt;,
	CallName=`@RPC2(GetColor), Abstract=`Obtain current color of a connection,
	ParmList =`@w&lt;<bf>in</bf> @RPC2(Handle) *Conn, <bf>out</bf> @RPC2(Integer) *Color&gt;,
	P1=`Conn, PD1=`Connection whose color is to be obtained,
	P2=`Color, PD2=`Current color of connection.,
	CC1=`@RPC2(SUCCESS), CCD1=`Color obtained.,
	CC2=`@RPC2(NOCONNECTION), CCD2=`Conn is bogus.,
	Text=`Useful if a package using RPC2 wants to save current color, set new color, then restore original color.
	)











</manpage>
