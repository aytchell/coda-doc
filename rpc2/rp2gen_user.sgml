
<chapt>The RP2Gen Stub Generator<p>
<label id="RP2GenChapter">

<sect>Introduction<P>
<bf>RP2GEN</bf> takes a description of a procedure call interface and generates
stubs to use the RPC2 package, making the interface available on remote
hosts.  RP2GEN is designed to work with a number of different languages (C, FORTRAN 77, PASCAL), however, only the C interface is currently
implemented.

RP2GEN also defines a set of external data representations for RPC types. 
These representations are defined at the end of this document in the
section entitled <bf>External Data Representations.</bf>  Any program wishing
to communicate with a remote program using the RP2GEN semantics must
obey these representation standards.

<sect>Usage<P>
RP2GEN is invoked as follows:

	rp2gen <em>file</em>



<em>File</em> is the file containing the description of the interface.  Normally,
these files have the extension <em>.rpc2</em>.  RPGen creates three files
named: <em>base</em>.client.c; <em>base</em>.server.c; and <em>base</em>.h,
where <em>base</em> is the name of the file without the extension and the
pathname prefix.
Thus:

            rp2gen <em>samoan.rpc2</em>

would yield the files: <em>samoan</em>.client.c; <em> samoan</em>.server.c; and <em>samoan</em>.h.

A person wanting to provide a package remotely writes his package with
a normal interface.  The client programmer writes his code to make normal
calls on the interface.  Then the client program is linked with:

            <bf> ld ... base.client.o /usr/andrew/lib/librpc2.a ...</bf>

and the server program with

             <bf>ld ... base.server.o /usr/andrew/lib/librpc2.a ...</bf>


The server module provides a routine, the <em>ExecuteRequest </em>routine,
that will decode the parameters of the request and make an appropriate
call on the interface.  (The routine is described below in the language
interface sections.)  The client module translates calls on the interface
to messages that are sent via the RPC2 package.  The<tt> .h</tt> file contains 
type definitions that RP2GEN generated from the type definitions in
the input file, and definitions for the op-codes used by RP2GEN.  This
file, which is automatically included in the server and client files,
may be included by any other module that needs access to these types.

<sect>Format of the Description File<P>
In the syntax of a description file below, non-terminals are represented
by <em>italic</em> names and literals are represented by <bf>bold</bf> strings.


<tabular ca=ll>
file ::= | prefixes header&lowbar;line default&lowbar;timeout decl&lowbar;or&lowbar;proc&lowbar;list
@
prefixes ::= | empty &verbar; prefix &verbar; prefix prefix
@
prefix ::= | <bf>Server Prefix</bf> string <bf>;</bf> &verbar; <bf>Client Prefix</bf> string <bf>;</bf>
@
header&lowbar;line ::= | <bf>Subsystem</bf> subsystem&lowbar;name <bf>;</bf>
@
subsystem&lowbar;name ::= | string
@
string ::= | <bf>"</bf> zero&lowbar;or&lowbar;more&lowbar;ascii&lowbar;chars <bf>"</bf>
@
default&lowbar;timeout ::= | <bf>Timeout</bf> <bf>(</bf> id&lowbar;number <bf>) ;</bf> &verbar; empty
@
decl&lowbar;or&lowbar;proc&lowbar;list ::= | decl&lowbar;or&lowbar;proc &verbar; decl&lowbar;or&lowbar;proc decl&lowbar;or&lowbar;proc&lowbar;list
@
decl&lowbar;or&lowbar;proc ::= | include &verbar; define &verbar; typedef &verbar; procedure&lowbar;description
@
include ::= | <bf>#include </bf> file&lowbar;name <bf></bf>
@
define ::= | <bf>#define</bf> identifier number
@
typedef ::= | <bf>typedef</bf> rpc2&lowbar;type identifier array&lowbar;spec <bf>;</bf>
@
rpc2&lowbar;type ::= | type&lowbar;name &verbar; rpc2&lowbar;struct &verbar; rpc2&lowbar;enum
@
type&lowbar;name ::@!= <bf>RPC2&lowbar;Integer)
</bf> &verbar; <bf>RPC2&lowbar;Unsigned </bf> &verbar; <bf>RPC2&lowbar;Byte </bf>
@
@/&verbar; <bf>RPC2&lowbar;String </bf> &verbar; <bf>RPC2&lowbar;CountedBS </bf> &verbar; <bf>RPC2&lowbar;BoundedBS </bf>
@
@/&verbar; <bf>SE&lowbar;</bf>Descriptor <bf>RPC2&lowbar;EncryptionKey </bf> &verbar; identifier
@
rpc2&lowbar;struct ::= | <bf>RPC2&lowbar;Struct  &lcub;</bf> field&lowbar;list <bf>&rcub;</bf>
@
field&lowbar;list ::= | field &verbar; field field&lowbar;list
@
field ::= | type&lowbar;name identifier&lowbar;list <bf>;</bf>
@
identifier&lowbar;list ::= | identifier &verbar; identifier <bf>,</bf> identifier&lowbar;list
@
rpc2&lowbar;enum ::= | <bf>RPC2&lowbar;Enum  &lcub;</bf> enum&lowbar;list <bf>&rcub;</bf>
@
enum&lowbar;list ::= | enum <bf>,</bf> enum&lowbar;list &verbar; enum
@
enum ::= | identifier <bf>=</bf> number
@
array&lowbar;spec ::= | empty &verbar; <bf>&lsqb;</bf> id&lowbar;number @b
@
id&lowbar;number ::= | number &verbar; identifier
@
@Hinge
@
procedure&lowbar;description ::= | @!proc&lowbar;name <bf>(</bf> formal&lowbar;list <bf> </bf>
@
@/timeout&lowbar;override new&lowbar;connection <bf>;</bf>
@
proc&lowbar;name ::= | identifier
@
formal&lowbar;list ::= | empty &verbar; formal&lowbar;parameter &verbar; formal&lowbar;parameter <bf>,</bf> formal&lowbar;list
@
formal&lowbar;parameter ::= | usage type&lowbar;name parameter&lowbar;name
@
usage ::= |  <bf>IN</bf> &verbar; <bf>OUT</bf> &verbar; <bf>IN OUT</bf>
@
parameter&lowbar;name ::= | identifier
@
timeout&lowbar;override ::= | <bf>Timeout</bf> <bf>(</bf> id&lowbar;number <bf> </bf> &verbar; empty
@
new&lowbar;connection ::= | <bf>NEW&lowbar;</bf>CONNECTION &verbar; empty
@
empty ::= |

</tabular>

In addition to the syntax above, text enclosed in /* and */
is treated as a comment and ignored.  Appearances of an include statement
will be replaced by the contents of the specified file.
All numbers
are in decimal and may be preceded by a single hyphen:  <bf>-</bf>, character.
Identifiers
follow C syntax except that the underline character: <bf>&lowbar;</bf>, may not
begin an identifier. (Note that a particular language interface defines
what identifiers may actually be used in various contexts.)

The following are reserved words in RP2GEN: <bf>server</bf>, <bf>client</bf>,
<bf>prefix</bf>, <bf>subsystem</bf>, <bf>timeout</bf>, <bf>typedef</bf>, <bf>rpc2&lowbar;</bf>struct, <bf>rpc2&lowbar;</bf>enum,
<bf>in</bf> and <bf>out</bf>.  Case is ignored for reserved words, so that, for
example, <bf>subsystem</bf> may be spelled as <bf>SubSystem</bf> if desired. 
Case is not ignored, however, for identifiers.  Note that the predefined
type names (RPC2&lowbar;Integer , RPC2&lowbar;Byte , etc.) are identifiers and must
be written exactly as given above.

The <em>prefixes</em> may be used to cause the names of the procedures in
the interface to be prefixed with a unique character string.  The line:

<itemize>
              Server Prefix "test";
</itemize>

will cause the server file to assume that the name of the server interface
procedure <em>name</em> is test&lowbar;<em>name</em>.  Likewise, the statement:

<itemize>  
             Client Prefix "real";
</itemize>

affects the client interface.  This feature is useful in case it is
necessary to link the client and server interfaces together.  Without
this feature, name conflicts would occur.

The <em>header&lowbar;</em>line defines the name of this subsystem.  The subsystem
name is used in generating a unique for the <em>execute request</em> routine.

The <em>default&lowbar;</em>timeout is used in both the server and client stubs. 
Both are specified in seconds.  Zero is interpreted as an infinite timeout
value.  The value specifies the timeout value used on RPC2&lowbar;MakeRPC ()
and RPC2&lowbar;SendResponse () calls in the client and server stubs respectively. 
The timeout parameter may be overriden for individual procedures by
specifying a <em>timeout&lowbar;</em>override.  Note that the timeouts apply to
each individual Unix blocking system call, not to the entire RPC2 procedure.

The <em>new&lowbar;</em>connection is used to designate at most one server procedure
that will be called when the subsystem receives the initial RPC2 connection. 
The new connection procedure must have 4 arguments in the following
order with the following usages and types:
<itemize>

(IN RPC2_Integer: SideEffectType
(IN RPC2_Integer: SecurityLevel 
(IN RPC2_Integer: EncryptionType
(IN RPC2_CountedBS: ClientIdent 
</itemize>


where <tt> SideEffectType, SecurityLevel, EncryptionType,</tt> and <tt> ClientIdent</tt> have the values
that were specified on the clients call to RPC2&lowbar;Bind.  Note that RP2Gen will automatically
perform an RPC2&lowbar;Enable  call at the end of this routine.
If no new connection procedure is specified, then the call to the <em>execute
request</em> routine with the initial connection request will return RPC2&lowbar;FAIL.

The <em>usage</em> tells whether the data for the parameter is to be copied
in, copied out, or copied in both directions.  The <em>usage</em> and <em>type&lowbar;</em>name
specifications together tell how the programmer should declare the parameters
in the server code.



<sect>Example 1: Common Definitions for Coda File System<P>
<Tscreen><verb>
/*
 * Include file common to callback.rpc2, vice.rpc2 and res.rpc2
 */

typedef RPC2&lowbar;Unsigned   VolumeId;
typedef VolumeId	       VolId;
typedef RPC2&lowbar;Unsigned	VnodeId;
typedef RPC2&lowbar;Unsigned	Unique;

typedef RPC2&lowbar;Struct 
	&lcub;
	VolumeId	Volume;
	VnodeId		Vnode;
	Unique		Unique;
	&rcub; ViceFid;

typedef RPC2&lowbar;Struct
	&lcub;
	RPC2&lowbar;Unsigned	Host;
	RPC2&lowbar;Unsigned	Uniquifier;
	&rcub; ViceStoreId;

typedef RPC2&lowbar;Struct
	&lcub;
	RPC2&lowbar;Integer	Site0;
	RPC2&lowbar;Integer	Site1;
	RPC2&lowbar;Integer	Site2;
	RPC2&lowbar;Integer	Site3;
	RPC2&lowbar;Integer	Site4;
	RPC2&lowbar;Integer	Site5;
	RPC2&lowbar;Integer	Site6;
	RPC2&lowbar;Integer	Site7;
	&rcub; ViceVersionArray;

typedef RPC2&lowbar;Struct
	&lcub;
	ViceVersionArray	Versions;
	ViceStoreId	StoreId;
	RPC2&lowbar;Unsigned	Flags;
	&rcub; ViceVersionVector;

typedef RPC2&lowbar;Unsigned	UserId;
typedef RPC2&lowbar;Unsigned	FileVersion;
typedef RPC2&lowbar;Unsigned	Date;
typedef RPC2&lowbar;Integer	Rights;

typedef	RPC2&lowbar;Enum 
	&lcub; 
	Invalid = 0,
	File = 1, 
	Directory = 2, 
	SymbolicLink = 3 
	&rcub; ViceDataType;

typedef RPC2&lowbar;Enum
	&lcub;
	NoCallBack = 0,
	CallBackSet = 1,
	BidFidReleased = 3
	&rcub; CallBackStatus;


typedef RPC2&lowbar;Struct
	&lcub;
	RPC2&lowbar;Unsigned	InterfaceVersion;
	ViceDataType	VnodeType;
	RPC2&lowbar;Integer	LinkCount;
	RPC2&lowbar;Unsigned	Length;
	FileVersion	DataVersion;
	ViceVersionVector	VV;
	Date		Date;
	UserId		Author;
	UserId		Owner;
	CallBackStatus	CallBack;
	Rights		MyAccess;
	Rights		AnyAccess;
	RPC2&lowbar;Unsigned	Mode;
	VnodeId		vparent;
	Unique		uparent;
	&rcub; ViceStatus;
</verb></Tscreen>



<sect>Example 2: The Coda Resolution Subsystem Interface<p>
<Tscreen><verb>
/* res.rpc2 
 * Defines the resolution subsystem interface
 * 
 * Created Puneet Kumar, June 1990
 */
server prefix "RS";
client prefix "Res";

Subsystem "resolution";

#define RESPORTAL	1361
#define RESOLUTIONSUBSYSID 5893

/* 
Return codes from the servers on resolution subsystem
*/
#define RES&lowbar;FAILURE	-512
#define	RES&lowbar;SUCCESS	0
#define RES&lowbar;TIMEDOUT	-513
#define RES&lowbar;NOTRUNT	-514
#define RES&lowbar;BADOPLIST	-515

#include "vcrcommon.rpc2"

typedef RPC2&lowbar;Struct
	&lcub;
	RPC2&lowbar;Integer	status;
	RPC2&lowbar;Unsigned	Author;
	RPC2&lowbar;Unsigned	Owner;
	RPC2&lowbar;Unsigned	Date;
	RPC2&lowbar;Unsigned 	Mode;
	&rcub; ResStatus;

typedef RPC2&lowbar;Struct
	&lcub;
	RPC2&lowbar;Integer		LogSize;
	ViceVersionVector 	VV;
	&rcub; ResVolParm;

typedef RPC2&lowbar;Enum
	&lcub;
	FetchStatus = 0,
	FetchSData = 1
	&rcub; ResFetchType;

typedef RPC2&lowbar;Enum
	&lcub;
	ResStoreStatus = 0,
	ResStoreData = 1
	&rcub; ResStoreType;

COP2	 (IN ViceStoreId StoreId,
		 IN ViceVersionVector UpdateSet);

NewConnection (IN RPC2&lowbar;Integer SideEffectType,
		 IN RPC2&lowbar;Integer SecurityLevel,
		 IN RPC2&lowbar;Integer EncryptionType,
		 IN RPC2&lowbar;CountedBS ClientIdent)
                 NEW&lowbar;CONNECTION;

ForceFile    (IN ViceFid Fid,
		 IN ResStoreType Request,
		 IN RPC2&lowbar;Integer Length,
		 IN ViceVersionVector VV,
		 IN ResStatus Status,
		 IN OUT SE&lowbar;Descriptor BD);

LockAndFetch (IN ViceFid Fid, 
		 IN ResFetchType Request, 
		 OUT ViceVersionVector VV,
		 OUT RPC2&lowbar;Integer logsize);

UnlockVol    (IN VolumeId Vid);

MarkInc      (IN ViceFid Fid);

FetchFile (IN ViceFid Fid, 
		 IN RPC2&lowbar;Unsigned PrimaryHost,
		 OUT ResStatus Status,
		 IN OUT SE&lowbar;Descriptor BD);

ForceDirVV (IN ViceFid Fid,
		 IN ViceVersionVector VV);

DoForceDirOps (IN ViceFid Fid,
		 IN ViceStatus status,
		 IN OUT RPC2&lowbar;CountedBS AccessList,
		 OUT RPC2&lowbar;Integer rstatus,
		 IN OUT SE&lowbar;Descriptor sed);

GetForceDirOps  (IN ViceFid Fid,
		 OUT ViceStatus status, 
		 IN OUT RPC2&lowbar;CountedBS AccessList,
		 IN OUT SE&lowbar;Descriptor sed);

FetchLog (IN ViceFid Fid,
		 OUT RPC2&lowbar;Integer logsize,
		 IN OUT SE&lowbar;Descriptor sed);

DirResPhase2 (IN ViceFid Fid,
		 IN ViceStoreId logid,
		 OUT ViceStatus status,
		 IN RPC2&lowbar;BoundedBS pbinc);

DirResPhase1 (IN ViceFid Fid, 
		 IN RPC2&lowbar;Integer size,
		 IN OUT ViceStatus status,
		 IN OUT RPC2&lowbar;BoundedBS piggyinc,
		 IN OUT SE&lowbar;Descriptor sed);

DirResPhase3 (IN ViceFid Fid,
		 IN ViceVersionVector UpdateSet,
		 IN OUT SE&lowbar;Descriptor sed);

</verb></Tscreen>




<sect>The C Interface<P>
This section describes the <bf>C interface</bf> generated by RP2GEN.  The following
table shows the relationship between RP2GEN parameter declarations and
the corrseponding C parameter declarations.

<table>
<tabular ca="l|r|r|r">
RPC2 Type | <bf>in</bf> | <bf>out</bf> | <bf>in out</bf>&gt;@
RPC2&lowbar;Integer  | long | long * | long *@
RPC2&lowbar;Unsigned  | unsigned long | unsigned long * | unsigned long *@
RPC2&lowbar;Byte  | unsigned char | unsigned char * | unsigned char *@
RPC2&lowbar;String  | unsigned char * | unsigned char * | unsigned char *@
RPC2&lowbar;CountedBS  | RPC2&lowbar;CountedBS  * | RPC2&lowbar;CountedBS  * | RPC2&lowbar;CountedBS  *@
RPC2&lowbar;BoundedBS  | RPC2&lowbar;BoundedBS  * | RPC2&lowbar;BoundedBS  * | RPC2&lowbar;BoundedBS  *@
RPC2&lowbar;EncryptionKey  | RPC2&lowbar;EncryptionKey  | RPC2&lowbar;EncryptionKey  * | RPC2&lowbar;EncryptionKey  *@
@SE(Descriptor) | <em>illegal</em> | <em>illegal</em> | @SE(Descriptor) *@
RPC2&lowbar;Enum  <em>name</em> | <em>name</em> | <em>name</em> * | <em>name</em> *@
RPC2&lowbar;Struct  <em>name</em> | <em>name</em> * | <em>name</em> * | <em>name</em> *@
RPC2&lowbar;Byte  <em>name&lsqb;...</em> | <em>name</em> | <em>name</em> | <em>name</em>@
</tabular>
<caption><label id="CDecls">
RP2Gen representation of parameters
</caption>
</table>



In all cases it is the caller's responsibility to allocate storage for
all parameters.  This means that for <tt> IN </tt>and<tt>  IN OUT </tt>parameters of a non-fixed
type, it is the callee's responsibility to ensure that the value to
be copied back to the caller does not exceed the storage allocated by
the callee.

The caller must call an RPC2 procedure with an initial implicit argument
of type RPC2&lowbar;Handle  that indicates the destination address(es) of the
target process(es).  The callee must declare the C routine that corresponds
to an RPC2 procedure with an initial implicit argument of type
RPC2&lowbar;Handle. 
Upon invocation, this argument will be bound to the address of a handle
that indicates the address of the caller.

RP2GEN also generates a routine that serves to decode an RPC2 request.
The name of this routine is "<em>subsystem&lowbar;</em>name&lowbar;ExecuteRequest",
and it is invoked as follows:

<itemize>
int <em>subsystem&lowbar;</em>name&lowbar;ExecuteRequest (cid, Request, bd)
    RPC2&lowbar;Handle cid;
    RPC2&lowbar;PacketBuffer *Request;
    SE&lowbar;Descriptor *bd;
</itemize>



This routine will unmarshall the arguments and call the appropriate
interface routine.  The return value from this routine will be the return
value from the interface routine.

The client program is responsible for actually making the connection
with the server and must pass the connection id as an additional parameter (the first) on each call to the interface.



<Sect>External Data Representations<p>
This section defines the external data representation used by RP2GEN,
that is, the representation that is sent out over the wire.  Each item
sent over on the wire is required to be a multiple of 4 (8-bit) bytes.  (Items
are padded as necessary to achieve this constraint.)  The bytes of an
item are numbered 0 through <em>n</em>-1 (where <em>n</em> <em>mod</em> 4 = 0).  The
bytes are read and written such that byte <em>m</em> always precedes byte
<em>m</em>+1.


<descrip>
<tag/RPC2&lowbar;Integer./ An RPC2&lowbar;Integer  is a 32-bit item that encodes an integer represented
in twos complement notation.  The most significant byte of the integer
is 0, and the least significant byte is 3.

<tag/RPC2&lowbar;Unsigned./  An RPC2&lowbar;Unsigned  is a 32-bit item that encodes an unsigned integer. 
The most significant byte of the integer is 0, the least significant
byte is 3.

<tag/RPC2&lowbar;Byte./  An RPC2&lowbar;Byte  is transmitted as a single byte followed by three padding
bytes.

<tag/RPC2&lowbar;String./  An RPC2&lowbar;String  is a C-style null-terminated character string.  It is
sent as an RPC2&lowbar;Integer  indicating the number of characters to follow,
not counting the null byte, which is, however, sent.  This is followed
by bytes representing the characters (padded to a multiple of 4), where
the first character (i.e., farthest from the null byte) is byte 0. 
An RPC2&lowbar;String  of length 0 is representing by sending an RPC2&lowbar;Integer 
with value 0, followed by a 0 byte and three padding bytes.

<tag/RPC2&lowbar;CountedBS./  An RPC2&lowbar;CountedBS  is used to represent a byte string of arbitrary
length.  The byte string is not terminated by a null byte.  An RPC2&lowbar;CountedBS 
is sent as an RPC2&lowbar;Integer  representing the number of bytes, followed
by the bytes themselves (padded to a multiple of 4 .  The byte with
the lowest address is sent as byte 0.

<tag/RPC2&lowbar;BoundedBS./  An RPC2&lowbar;BoundedBS  is intended to allow you to remotely play the game
that C programmers play: allocate a large buffer, fill in some bytes,
then call a procedure that takes this buffer as a parameter and replaces
its contents by a possibly longer sequence of bytes.  An RPC2&lowbar;BoundedBS 
is transmitted as two RPC2&lowbar;Integer s representing the maximum and current
lengths of the byte strings.  This is followed by the  bytes representing
the contents of the buffer (padded to a multiple of 4).  The byte with
the lowest address is byte 0.

<tag/RPC2&lowbar;EncryptionKey./  An RPC2&lowbar;EncryptionKey  is used to transmit an encryption key (surprise!). 
A key is sent as a sequence of RPC2&lowbar;KEYSIZE  bytes, padded to a multiple
of 4.  Element 0 of the array is byte 0.

@SE(Descriptor)@\Objects of type @SE(Descriptor) are never transmitted.

<tag/RPC2&lowbar;Struct./  An RPC2&lowbar;Struct  is transmitted as a sequence of items representing its
fields.  The fields are sent in textual order of declaration (i.e.,
from left to right and top to bottom).  Each field is sent using, recursively,
its RPC2 representation.

<tag/RPC2&lowbar;Enum./  An RPC2&lowbar;Enum  has the same representation has an RPC2&lowbar;Integer , and the
underlying integer used by the compiler is transmitted as the value
of an RPC2&lowbar;Enum.  (Note that in C, this underlying value may be specified
by the user.  This is recommended practice.)

<tag/Array./  The total number of bytes transmitted for an array must be
a multiple of 4.
However, the number of bytes sent for each element depends on the type of
the element.
</descrip>


Currently, only arrays of RPC2&lowbar;Byte  are defined.
The elements of such an array are each sent as a single byte (no padding),
with array element, <em>n-1,</em> preceding element, <em>n</em>.



